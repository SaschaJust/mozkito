%!PS-Adobe-3.0 %%Creator: Adobe Illustrator(R) 8.0%%AI8_CreatorVersion: 16.0.1%%For: (Sascha Just) ()%%Title: (genealogies.ai)%%CreationDate: 12/13/12 12:48 AM%%Canvassize: 16383%%BoundingBox: 277 -139 333 -84%%HiResBoundingBox: 277 -138.6973 333 -84%%DocumentProcessColors: Cyan Magenta Yellow Black%%DocumentSuppliedResources: procset Adobe_level2_AI5 1.2 0%%+ procset AGM_Gradient 1.0 0%%+ procset Adobe_ColorImage_AI6 1.3 0%%+ procset Adobe_Illustrator_AI5 1.3 0%%+ procset Adobe_cshow 2.0 8%%+ procset Adobe_shading_AI8 1.0 0%AI5_FileFormat 4.0%AI3_ColorUsage: Color%AI7_ImageSettings: 0%%RGBProcessColor: 0 0 0 ([Registration])%%AI6_ColorSeparationSet: 1 1 (AI6 Default Color Separation Set) %%+ Options: 1 16 0 1 1 1 0 0 0 0 1 1 1 18 0 0 0 0 0 0 0 0 -1 -1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 2 3 4%%+ PPD: 1 21 0 0 60 45 2 2 1 0 0 1 0 0 0 0 0 0 0 0 -1 -1 () %AI3_TemplateBox: 305.5 396.5 305.5 396.5%AI3_TileBox: -97.5 117 685.5 676%AI3_DocumentPreview: None%AI5_ArtSize: 57 55%AI5_RulerUnits: 2%AI5_ArtFlags: 0 0 0 1 0 0 1 0 0%AI5_TargetResolution: 800%AI5_NumLayers: 1%AI8_OpenToView: -927 1020 1 2469 1257 26 0 0 46 133 0 0%AI5_OpenViewLayers: 7%%PageOrigin:0 0%AI7_GridSettings: 72 8 72 8 1 0 0.8 0.8 0.8 0.9 0.9 0.9%AI9_Flatten: 1%AI12_CMSettings: 00.MS%AI7_Thumbnail: 128 128 8%%BeginData: 11712 Hex Bytes%0000330000660000990000CC0033000033330033660033990033CC0033FF%0066000066330066660066990066CC0066FF009900009933009966009999%0099CC0099FF00CC0000CC3300CC6600CC9900CCCC00CCFF00FF3300FF66%00FF9900FFCC3300003300333300663300993300CC3300FF333300333333%3333663333993333CC3333FF3366003366333366663366993366CC3366FF%3399003399333399663399993399CC3399FF33CC0033CC3333CC6633CC99%33CCCC33CCFF33FF0033FF3333FF6633FF9933FFCC33FFFF660000660033%6600666600996600CC6600FF6633006633336633666633996633CC6633FF%6666006666336666666666996666CC6666FF669900669933669966669999%6699CC6699FF66CC0066CC3366CC6666CC9966CCCC66CCFF66FF0066FF33%66FF6666FF9966FFCC66FFFF9900009900339900669900999900CC9900FF%9933009933339933669933999933CC9933FF996600996633996666996699%9966CC9966FF9999009999339999669999999999CC9999FF99CC0099CC33%99CC6699CC9999CCCC99CCFF99FF0099FF3399FF6699FF9999FFCC99FFFF%CC0000CC0033CC0066CC0099CC00CCCC00FFCC3300CC3333CC3366CC3399%CC33CCCC33FFCC6600CC6633CC6666CC6699CC66CCCC66FFCC9900CC9933%CC9966CC9999CC99CCCC99FFCCCC00CCCC33CCCC66CCCC99CCCCCCCCCCFF%CCFF00CCFF33CCFF66CCFF99CCFFCCCCFFFFFF0033FF0066FF0099FF00CC%FF3300FF3333FF3366FF3399FF33CCFF33FFFF6600FF6633FF6666FF6699%FF66CCFF66FFFF9900FF9933FF9966FF9999FF99CCFF99FFFFCC00FFCC33%FFCC66FFCC99FFCCCCFFCCFFFFFF33FFFF66FFFF99FFFFCC110000001100%000011111111220000002200000022222222440000004400000044444444%550000005500000055555555770000007700000077777777880000008800%000088888888AA000000AA000000AAAAAAAABB000000BB000000BBBBBBBB%DD000000DD000000DDDDDDDDEE000000EE000000EEEEEEEE0000000000FF%00FF0000FFFFFF0000FF00FFFFFF00FFFFFF%524C45FD53FF7D2121270027F852FD78FF52F827F821F80077FD78FF2721%F8272127F8A8FD77FF7D21F821F821F821A8FD77FF7DF82700272127F87D%FD77FF2721F821F827F821F827A8FD74FFA827F8272127F82700F8F8F87D%FD73FFA8F821F821F821F821FD04F827A8FD71FF7D2121272127212721F8%F827F8F8F8A8FD70FF52F821F827F821F827FD07F852A8FD10FFA2A8FD5C%FF2727212700272127FD09F8277DFD0FFF777DFD5BFFA827F827F821F827%F827FD0AF827FD0EFFA8F8A8FD5BFF212721272127212727A827F8F827F8%F8F827F8F8F8A8FD0DFF2727FD5AFFA821F8270021F827F827FFFF52FD0A%F852FD0CFF27F877FD59FFA8212700272127002721A9FFFFA827FD09F827%A8FD0AFF7DF827A8FD58FF7D21F821F827F821F821A2FFFFFFA852FD0AF8%52FD09FF7700F84CFD58FFA8002721272127212700A8FD05FFA8F8F8F827%F8F8F827F8F827FD08FFA82127F87DFD57FF77210021F8270021F8217DFD%07FF27FD0AF87DFD06FFA827F821F8A8FD56FF7DF827212721272127F87D%FD08FF7D27FD05F827F8F8F852A8FD05FF2727212127FD56FF77F8F827F8%21F827F82127FD09FFA827FD0AF87DFD04FF52F827F8F852FD55FF7DF827%212721272127004CFD0BFF7DF8F8F827F8F8F827F8F827FFFFFF7D212127%0027A8FD54FF77F8F8272121F827212121FD0DFF27FD0AF87DFFA8F82700%21F828FD54FFA2F8272127212721272127A8FD0DFF52F8F827F8F8F827F8%F8F852A82700272127F87DFD53FF7D21F821F8270021F821F87DFD0EFFA8%27FD09F8272121F827F821F8A8FD52FFA82127212721272127212152FD10%FF7DF8F8F827F827F827F82721272127212727FD52FF7D210021F8272121%F827F852FD11FFA8FD09F821F8272121F82152FD51FFA821272127212721%27212727FD13FF52F8F827F8F8F82721272127212721217DFD50FFA821F8%270021F8270021F82152FD13FF7D27FD05F8270021F827F821F827FD51FF%2127212721272127212721F827A8FD13FF52F8F8F8272127212721272127%21FD51FF27F8272121002721210027F8F8F87DFD13FFA8F8F8F8272121F8%272121F827FD51FF4C2121272127212721272127F8F8F827A8FD13FF27F8%212721272127212127FD51FF52F821F8272121F8272121FD06F852FD13FF%5321F8270021F827F852FD51FF772121272127212721272127F827F827F8%F827FD13FF212721272127212177FD51FFA2F82100272121002721212127%FD07F87DFD10FFA827F82721210027F87DFD51FFA2272127212721272127%2127F827F827F827F8F8F852A8FD0FFF2127212721272127A8FD51FFA800%212121F8272121F8272121FD09F8277DFD0DFFA827F821F827212121FD53%FF4C21272127212721272127277DF8F8F827F827F827F8F852FD0DFF2127%212721270052FD53FF4CFD042127212121272121A8FF27F8F827F8F8F827%F8F8F87DFD0AFF7D2721210027212152FD53FF7DF8272127212721272127%F87DFFFF7DF8F827F827F827F8F8F852FD09FFA800272127212721A8FD53%FF7D21F827212100272121002152FFFFFFA827FD09F8277DFD07FF7D21F8%272121F827A8FD53FFA821272127212721272127214CFD05FF7DF8F8F827%F827F827F8F852FD06FF7DF8272127212752FD54FFA827F8272121212721%21212721FD06FFA827F8F827F8F8F827F8F8F8A8FD04FF4C2121272121F8%A2FD55FF4C2121272127212721272127A2FD07FF52F8F827F827F827F8F8%F87DFFFFA84C212721272127A8FD55FF77F8210027212100272121F87DFD%08FF7D27FD09F827A8A8F821212100214CFD56FF7D212127212721272127%212152FD09FFA852F8F8F827F827F827F85277272127212721A8FD56FFA8%21212127212121272121F84CFD0BFFA8F8F8F827F8F8F827F82721272121%F84CFD58FF4C2127212721272127212721FD0DFF52F8F827F827F8272127%212721217DFD58FF4CFD042127212121272121A2FD0DFF7DFD06F8272121%002121FD59FF7D2127212721272127212721A8FD0EFFA852F82727272127%2127217DFD59FF7D212127212721272127212177FD11FFA852F8272121F8%4CFD5BFF212721272127212721272177FD11FFA82127212721217DFD5BFF%4CF82721212127FD042128FD10FFA8FD062128FD5CFF5227212721282127%2128214CFD10FF28272127212721A8FD5CFF7DF827212721272127212721%CBFD0EFF4C2121272127F87DFD5DFFA82721272127212721272127A8FD0D%FF522121272127214CFD5FFF21212127212121272121F8A2FD0CFF282121%272121F821A8FD5FFF52214C2127214C212721217DFD0AFFCB2721212821%2721217DFD60FF52212127212721272127F87DFD09FF7D21212127212721%2152FD61FFA82127212721272127212152FD07FF7D4C2127212721272121%4CFD62FFA82721212127212121270052FD05FFA84C21F827212121272121%21FD64FF2727214C2127214C21274CFFFFFF7D522121214C2127214C2121%21FD65FF522127212721272127214CA27D2721F827212721272127212121%A8FD65FF77212127212821272128212721272127212821272127212121CB%FD66FFA2F82721212127212121272121212721212127FD0521A8FD67FF7D%282127214C2127214C2127214C2127214C212721214CFD62FFCBFF7D7D52%4C2121212721272127212721272127212721272127212152FD5FFFA87D7D%524C2127212121272127214C2127214C2127214C21272128212721277DFD%5AFFA8A8777727282121F8FD042127212721272127212721212127212121%2721212127F84CA8FD56FFA8A87D77274C212121272127214C214C214C21%28214C2128214C2128214C2128214C21282127217DFD53FFA8A877532727%FD0521272127212721272127212721272127212721272127212721272127%212721214CA8FD51FFA87D4C4C212121272127214C2127214C2127214C21%27214C2127214C2127214C2127214C2127214C2127214C7DFD4FFFA87D52%212100212127212721272127212721272127212721272127212721272127%212721272127212721272121277DA8FD4DFFCB77522121214C214C214C21%4C214C214C214C214C214C214C214C214C214C214C214C214C214C214C21%4C214C212752FD4DFFA8774C212121272127212721272127212721272127%21272127212721272127212721272127212721272127212721272127F87D%FD4BFFA2772121214C2128214C2128214C2128214C2128214C2128214C21%27214C2127214C2127214C2127214C2127214C2127214C21217DFD48FFA8%7D2721212721272127212721272127212721272127212721272127212721%27212721272127212721272121F827282821272127212721A8FD47FF7D4C%2127214C214C214C214C214C214C214C214C214C214C214C214C214C214C%214C214C214C214C2127214C4C7DA8FF4C28214C214C214CA8FD45FFA221%21214C212721282127212821272128212721272127212721272127212721%2721272127FD05214C52A8A8FD04FF4C21272127212721FD44FFA84C214C%214C214C214C214C214C214C214C214C214C214C214C214C214C214C2127%21272121214C527DA2FD09FF4C27214C21282152FD42FFCB4C2121272127%212721272127212721272127212721272127212721272127FD05214C4C7D%7DA8A8FD0BFFA84C21272127212152FD41FFA82727214C214C214C214C21%4C214C214C214C214C214C214C214C214C214C215277A2A8FD13FF272821%4C214C21A8FD3FFFA8772121214C2127214C2127214C2127214C21272127%FD05212721272127F82727FD15FFA84C212721272127A8FD3EFFA84C214C%214C214C214C214C214C214C214C212721212152527D5227F827F8272727%F827277DFD13FFA8214C214C21274CFD3EFF7D2721272127212721272127%2127FD05214C4C7DA2CBA8FFFFFF7D27F827F827F827F827F852A8FD11FF%7D2121272127F87DFD3DFF7D4C214C214C214C214C214C214C214C4C777D%CBFD0AFFA852F8FD0727F8277DFD10FF7D214C214C214CA8FD3CFF772121%4C2127214C2127214C21214CA2A8FD10FF7DF827F827F827F827F82752FD%0FFF5221214C212127FD3CFF7721214C214C214C214C214C21272152FD14%FFFD0427F8272727F82727A8FD0DFF4C214C214C217DFD3BFF7721214C21%27214C212121272127F827F8277DFD13FF5227F827F827F827F827F852A8%FD0AFFA8212721272127A8FD3AFF7D21214C214C214C214C21FD0727F827%52FD13FFA852F8FD0727F852A8FD09FF7727214C212852FD3AFF7D212127%214C21212152A8A82727F827F827F827F82727A8FD13FF7DF827F827F827%F827F82752FD07FFA84C214C212721A8FD39FFA84C214C214C214C217DFD%04FF5227F827F8FD0527F87DFD13FFA8FD0427F8272727F82727A8FD05FF%A2214C214C214CFD39FFA84C2127214C212127A8FD06FFA852F827F827F8%27F827F8277DFD13FF5227F827F827F827F827F87DFD04FF272121272121%7DFD39FF77214C214C21214CFD0AFF7DF8FD0727F8277DFD13FFA827F8FD%0727F852A8FF7D28214C214C4CFD39FF7D214C212721214CFD0CFFA82727%F827F827F827F82727A8FD12FFA852F827F827F827F827F827A84C214C21%2721A8FD39FF274C214C21214CFD0FFF5227F8FD08277DFD13FFA8FD0827%044C214C214C2177FD39FF4C21212721214CFD11FF7D27F827F827F827F8%27F852A8FD13FF2727F827F827F827214C21272127A8FD38FFA24C214C21%4C21A8FD13FF7DF8FD0727F8277DFD13FF7D27F8272727214C214C21277D%FD39FF4C214C214C2127277DFD13FFA82727F827F8272727F82727A8FD12%FFA852F8272127214C21214CFD39FFA8214C214C214C2727F852A8FD13FF%52FD0A277DFD13FF77214C214C214C21FD3AFF2721214C214C2127F827F8%277DFD13FF7D27F827F827F827F827F852A8FD0FFFA8772127214C212121%A2FD39FF7D4C274C214CFD082752FD13FFA852F8FD0727F8277DFD0DFFA8%52214C214C214C217DFD3AFF4C214C214C2127F827F8272727F827277DFD%13FF7DF8272727F8272727F82752FD0BFF5221214C2127214C2177FD3AFF%A8214C214C214C7727F8FD0727F852A8FD12FFA8FD0B27A8FD06FFCB7D21%27214C214C214C2152FD3BFF5221214C21214CFFA852F827F827F827F827%F8277DFD13FF5227F827F827F827F827F852A8FFFFA8524C2121214C2127%214C214CA8FD3AFFCB4C214C214C217DFFFFFF7DFD0827F82752FD13FFA8%52F8FD0727F8527D77214C214C214C274C214C2152FD3CFFA2214C214C21%4CA2FD04FFA82727F827F8272727F82727A8FD13FF7DF8272727F8272127%21212127214C214C214C214C214CCBFD3CFF5245214C214C21FD07FF7DFD%0927F87DFD13FFA82727274C214C214C214C214C214C214C214C2177FD3D%FFA84C214C214C214CA8FD07FFA852F827F8272727F827F8277DFD0DFFA8%A87D774C4C214C214C214C214C214C214C214C21212177FD3EFFA8214C21%4C274C4CFD0AFF7DFD0827F8277DFD07FFA8A87D7D4C4C214C214C214C27%4C214C274C214C274C214C274C21A2FD3FFF7721214C214C2177FD0BFFA8%FD0427F8272727F82727A8A2A277524B4C2121214C214C214C214C214C21%4C214C214C214C214C21214CA8FD40FF77214C274C214C77FD0DFF52FD06%274C214C214C214C214C214C214C214C214C214C214C214C214C214C214C%214C214C77FD42FF214C214C214C2177FD0CFFA8A84C27214C214C214C21%4C214C214C214C214C214C214C214C214C214C214C214C214C2121214CA2%FD42FFA84C214C4C4C214C7DFD08FFCB7D774C4C214C4C4C214C4B4C214C%4B4C214C274C214C274C214C274C214C274C214C274C214C214C21A2FD44%FFA2214C214C214C21A2FD04FFA27D4C4C2121214C214C214C214C214C21%4C214C214C214C214C214C214C214C214C214C214C214C214C214C77CBFD%45FF774C4B4C214C4B4C77FFA2774C4C214C214C4B4C214C274C214C274C%214C274C214C274C214C274C214C274C214C274C214C214C214C2177A8FD%47FF77214C214C214C214C21452145214C214C214C214C214C214C214C21%4C214C214C214C214C214C214C214C214C214C214C2145214C52CBFD49FF%FD044C214C4C4C214C4C4C214C4C4C214C4C4C214C4C4C214C4C4C214C4C%4C214C4C4C214C4C4C214C4C4C214C4B4C214C4CA2A8FD4BFF4C214C214C%214C214C214C214C214C214C214C214C214C214C214C214C214C214C214C%214C214C214C214C2121214C4C77A2FD4DFFA84C4C214C4C4C214C4C4C21%4C4C4C214C4C4C214C4B4C214C4B4C214C4B4C214C4B4C214C4B4C214C21%4C214C4C77A2FD4EFFA252214C214C214C214C214C214C214C214C214C21%4C214C214C214C214C214C214C214C214C214C2121214C4C7DA2FD50FF77%4C214C4C4C454C4C4C454C4C4C214C4C4C214C4C4C214C4C4C214C4C4C21%4C4C4C214C214C214C4C5277A8A8FD51FF7D214C214C214C214C214C214C%214C214C214C214C214C214C214C214C214C214C214C2121214C4C7D7DCB%FD53FFA24C214C214C4C4C214C4C4C214C4C4C214C4C4C214C4C4C214C4C%4C214C214C214C454C4C7D7DA8A8FD56FF7745214C214C214C214C214C21%4C214C214C214C214C214C214621462146214C527D7DA8A8FD5AFF4C4C21%4C4C4C464C4C4C454C4C4C454C4C4C454C464C214C214C4C7777A2A8FD5F%FFA22146214C214C214C214C214C214C214C214C214C214C4C7777A8A8FD%63FFA245FD154CA8FD68FFA8CBA8CBA8FFA8CBA8FFA8CBA8FFA8CBA8FFA8%CBA8FFA8FD68FFFF%%EndData%%EndComments%%BeginProlog%%BeginResource: procset Adobe_level2_AI5 1.2 0
%%Title: (Adobe Illustrator (R) Version 5.0 Level 2 Emulation)
%%Version: 1.2 0
%%CreationDate: (04/10/93) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
userdict /Adobe_level2_AI5 26 dict dup begin
	put
	/packedarray where not
	{
		userdict begin
		/packedarray
		{
			array astore readonly
		} bind def
		/setpacking /pop load def
		/currentpacking false def
	 end
		0
	} if
	pop
	userdict /defaultpacking currentpacking put true setpacking
	/initialize
	{
		Adobe_level2_AI5 begin
	} bind def
	/terminate
	{
		currentdict Adobe_level2_AI5 eq
		{
		 end
		} if
	} bind def
	mark
	/setcustomcolor where not
	{
		/findcmykcustomcolor
		{
			(AI8_CMYK_CustomColor)
			6 packedarray
		} bind def
		/findrgbcustomcolor
		{
			(AI8_RGB_CustomColor)
			5 packedarray
		} bind def
		/setcustomcolor
		{
			exch 
			aload pop dup
			(AI8_CMYK_CustomColor) eq
			{
				pop pop
				4
				{
					4 index mul
					4 1 roll
				} repeat
				5 -1 roll pop
				setcmykcolor
			}
			{
				dup (AI8_RGB_CustomColor) eq
				{
					pop pop
					3
					{
						1 exch sub
						3 index mul 
						1 exch sub
						3 1 roll
					} repeat
					4 -1 roll pop
					setrgbcolor
				}
				{
					pop
					4
					{
						4 index mul 4 1 roll
					} repeat
					5 -1 roll pop
					setcmykcolor
				} ifelse
			} ifelse
		}
		def
	} if
	/setAIseparationgray
	{
		false setoverprint
		0 setgray
		/setseparationgray where{
			pop setseparationgray
		}{
			/setcolorspace where{
				pop
				[/Separation (All) /DeviceCMYK {dup dup dup}] setcolorspace
				1 exch sub setcolor
			}{
				setgray
			}ifelse
		}ifelse
	} def
	
	/gt38? mark {version cvr cvx exec} stopped {cleartomark true} {38 gt exch pop} ifelse def
	userdict /deviceDPI 72 0 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt put
	userdict /level2?
	systemdict /languagelevel known dup
	{
		pop systemdict /languagelevel get 2 ge
	} if
	put
/level2ScreenFreq
{
 begin
		60
		HalftoneType 1 eq
		{
			pop Frequency
		} if
		HalftoneType 2 eq
		{
			pop GrayFrequency
		} if
		HalftoneType 5 eq
		{
			pop Default level2ScreenFreq
		} if
 end
} bind def
userdict /currentScreenFreq  
	level2? {currenthalftone level2ScreenFreq} {currentscreen pop pop} ifelse put
level2? not
	{
		/setcmykcolor where not
		{
			/setcmykcolor
			{
				exch .11 mul add exch .59 mul add exch .3 mul add
				1 exch sub setgray
			} def
		} if
		/currentcmykcolor where not
		{
			/currentcmykcolor
			{
				0 0 0 1 currentgray sub
			} def
		} if
		/setoverprint where not
		{
			/setoverprint /pop load def
		} if
		/selectfont where not
		{
			/selectfont
			{
				exch findfont exch
				dup type /arraytype eq
				{
					makefont
				}
				{
					scalefont
				} ifelse
				setfont
			} bind def
		} if
		/cshow where not
		{
			/cshow
			{
				[
				0 0 5 -1 roll aload pop
				] cvx bind forall
			} bind def
		} if
	} if
	cleartomark
	/anyColor?
	{
		add add add 0 ne
	} bind def
	/testColor
	{
		gsave
		setcmykcolor currentcmykcolor
		grestore
	} bind def
	/testCMYKColorThrough
	{
		testColor anyColor?
	} bind def
	userdict /composite?
	1 0 0 0 testCMYKColorThrough
	0 1 0 0 testCMYKColorThrough
	0 0 1 0 testCMYKColorThrough
	0 0 0 1 testCMYKColorThrough
	and and and
	put
	composite? not
	{
		userdict begin
		gsave
		/cyan? 1 0 0 0 testCMYKColorThrough def
		/magenta? 0 1 0 0 testCMYKColorThrough def
		/yellow? 0 0 1 0 testCMYKColorThrough def
		/black? 0 0 0 1 testCMYKColorThrough def
		grestore
		/isCMYKSep? cyan? magenta? yellow? black? or or or def
		/customColor? isCMYKSep? not def
	 end
	} if
 end defaultpacking setpacking
%%EndResource
%%BeginResource: procset AGM_Gradient_Sep 1.0 0
%%Title: (AGM Gradient Procset)
%%Version: 1.0 0
%%CreationDate: (4/26/96) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
userdict /defaultpacking currentpacking put true setpacking
userdict /AGM_Gradient_Sep 5 dict dup begin put
/AGM_Gradient_Sep_private 100 dict def
/initialize{
	AGM_Gradient_Sep begin
	AGM_Gradient_Sep_private begin
	_compositeJob{
		initializeSinglePassSeps
	}{
		initializeMultiPassSeps
	}ifelse
	initializeSeps
	AGM_Gradient_private begin
		/_fillSD newSpotDict def
		/_rampSD newSpotDict def
		/_nCustomColorSD nd
 end
	AGM_Gradient_Sep_private 
	{
		dup xcheck 1 index type /arraytype eq and
		{
			bind
		}if
		pop pop
	}forall
	AGM_Gradient_Sep
	{
		dup xcheck 1 index type /arraytype eq and
		{
			bind
		}if
		pop pop
	}forall
 end
	
	currentdict readonly pop	
 end
}def
/terminate{
	currentdict AGM_Gradient_Sep eq{
	 end
	}if
}def
AGM_Gradient_Sep_private begin
/initializeSeps{
	/currentoverprint { _of } def
	_noImage not _level2PS not and{
		/linealFill{
			currentoverprint{
				0 0 1 1 rectfill
			}{
				mySave
				8 setImageParms
				_color{
					_nCustomColorSD begin
						cyan magenta yellow black
	
						_spotColor{
							spot1/tintImage spot1/tintValue get 1 exch sub makeByte8 put
							spot2/tintImage spot2/tintValue get 1 exch sub makeByte8 put
						}if
				 end
	
					4{
						makeByte8 4 1 roll
					}repeat
					true 4 _nCustomColorSD ncolorimage
				}{
					_nCustomColorSD/black get 1 exch sub makeByte8 
					_nCustomColorSD bwImage
				}ifelse
				myRestore
			}ifelse
		}def
	}if
	/_whiteBytes 1 makeByte8 pt
	 /knockOut{
		_noImage _level2PS or currentoverprint or{
			gsave
			false setoverprint
			1 setgray 
			0 0 1 1 rectfill
			grestore
		}{
			8 setImageParms _whiteBytes /_image load 5 execImage
		}ifelse
	}def
	/newSpotDict{
		11 dict dup begin
			/nSpots 2 def
			/spot1 7 dict def
			/spot2 7 dict def
	 end
	}def
	/initSpotData
	{
	 begin
			/name nd
			/tintImage nd
			/tintValue nd
			/spot_C nd
			/spot_M nd
			/spot_Y nd
			/spot_K nd
	 end
	}def
	/initSpotDict{
	 begin
			/cyanInk nd
			/magentaInk nd
			/yellowInk nd
			/blackInk nd
			/cyan nd
			/magenta nd
			/yellow nd
			/black nd
			spot1 initSpotData
			spot2 initSpotData
	 end
	}def
	/copySpotDict{
		/_dst xp
	 begin
			cyanInk magentaInk yellowInk blackInk
			cyan magenta yellow black
			spot1 spot2
	 end
		_dst begin
			/spot1 spot1 maxlength dict def
			/spot2 spot2 maxlength dict def
			spot2 copy pop
			spot1 copy pop
			/black xd
			/yellow xd
			/magenta xd
			/cyan xd
			/blackInk xd
			/yellowInk xd
			/magentaInk xd
			/cyanInk xd
	 end
	}def
	/setCustomColor
	{
		1 index /Black eq{
			6 1 roll 5 npop
			1 exch sub
			setgray
		}{
			6 1 roll _ccAry1 astore exch
			dup null eq{
				pop 0
			}if
			setcustomcolor
		}ifelse
	}def
	/setCStop{
		/_colorStyle exch pt
		
		_colorStyle 0 eq{
			0 0 0
			4 -1 roll
			1 exch sub
			_spotColor{
				/_colorStyle 3 pt
				/Black
				1 index
				1 exch sub
			}if
		}if
		_colorStyle 2 eq{
			3 npop
		}if
		_rampSD _fillSD copySpotDict
		
		_colorStyle 4 eq{ 
			pop
			9 2 roll 3 npop 6 -2 roll
		} if
		
		_colorStyle 3 eq _colorStyle 4 eq or{ 	
				
			_fillSD begin
				/_spot1 spot1 pt
				/_spot2 spot2 pt
		 end
			
			exch dup _spot1/name get eq{
				_spot1 _spot2
			}{
				_spot2 _spot1
			}ifelse
		 begin
			 begin
					/name xd
					1 exch sub /tintValue xd
					4{
						tintValue mul 4 1 roll
					}repeat
					_spotColor not{
						/tintValue null def
					}if
			 end
				/tintValue 0 def
		 end
		}if
		_fillSD nsetcustomcolor
	}def
	/renderCMYK{
		spot1/name get null eq
		spot2/name get null eq and
		dup not{
			pop
			spot1 spotConverted
		}if
		dup not{
			pop
			spot2 spotConverted
		}if
	}def
	/currentInk{
		true
		_inRipSep{
			currentcolorspace 0 get
			dup /DeviceGray eq
			1 index /DeviceCMYK eq or{
				pop
				currentcmykcolor add add add 0 eq{
					pop false
				}if
			}{
				/Separation eq{
					currentcolor 0 eq{
						pop false
					}if
				}if
			}ifelse
		}{
			currentgray 1 eq{
				pop false
			}if
		}ifelse
	}def
	/currentInkN{
	
		_nCustomColorSD begin
			/_spot1 spot1 pt
			/_spot2 spot2 pt
			renderCMYK
	 end
		{
			currentInk
		}{
			gsave
			_spot1 begin
				name null ne{
					spot_C spot_M spot_Y spot_K name tintValue setCustomColor
					currentInk
				}{
					false
				}ifelse
		 end
			_spot2 begin
				name null ne{
					spot_C spot_M spot_Y spot_K name tintValue setCustomColor
					currentInk
				}{
					false
				}ifelse
		 end
			grestore
			
			or
		} ifelse
	}def
	/fill_ /fill load def
	/fillOvp{
		currentoverprint{
			_inRipSep{
				currentcolorspace 0 get
				dup /DeviceGray eq
				1 index /DeviceCMYK eq or{
					pop
					currentcmykcolor add add add 0 eq{
						newpath
					}if
				}{
					/Separation eq{
						currentcolor 0 eq{
							newpath
						}if
					}if
				}ifelse
			}{
				currentgray 1 eq{
					newpath
				}if
			}ifelse
		}if
		fill_
	}def
	/fill{
		_nCustomColorSD begin
			/_spot1 spot1 pt
			/_spot2 spot2 pt
			renderCMYK
	 end
		
		{
			fillOvp
		}{
			_spot1 begin
				gsave
				name null ne{
					spot_C spot_M spot_Y spot_K name tintValue setCustomColor
				}{
					1 setgray
				}ifelse
				fillOvp 
				grestore
		 end
			_spot2 begin
				name null ne{
					gsave
					true setoverprint
					spot_C spot_M spot_Y spot_K name tintValue setCustomColor
					fillOvp
					grestore
				}if
		 end
			newpath
		}ifelse
	}def
	/expandSpot{
		_spotColor{
			/_len xp
			_rampSD begin
				spot1 begin
					tintImage null ne{
						tintImage _len expandOne /tintImage xd
					}if
			 end
				spot2 begin
					tintImage null ne{
						tintImage _len expandOne /tintImage xd
					}if
			 end
		 end
		}{
			pop
		}ifelse
	}def
	/rampImage{
		currentoverprint{
			rectImage
		}{
			_enabledSmoothShade{
				fillRamp
			}{
				_color{
					_rampSD begin
						/cyanInk _cyanData 0 ne def
						/magentaInk _magentaData 0 ne def
						/yellowInk _yellowData 0 ne def
						/blackInk _blackData 0 ne def
				 end
					
					_nSamples setImageParms
					_nSamples expandSpot
					_cyanData _magentaData _yellowData _blackData _nSamples 4 expandColor
					true 4 _rampSD ncolorimage
				}{
					_rampSD begin
						/cyanInk false def
						/magentaInk false def
						/yellowInk false def
						/blackInk true def
				 end
					_nSamples setImageParms 
					_blackData _rampSD bwImage
				}ifelse
			}ifelse
		}ifelse
	}def
	/nsetcustomcolor where{
		pop
	}{
		/nsetcustomcolor
		{
			/_nCustomColorSD xp
			_nCustomColorSD begin
				4 copy
				/black xd
				/yellow xd
				/magenta xd
				/cyan xd
				4 copy
				0 ne /blackInk xd
				0 ne /yellowInk xd
				0 ne /magentaInk xd
				0 ne /cyanInk xd
		 end
			setcmykcolor
		}def
	}ifelse
	/nsetcustomcolorend where{
		pop
	}{
		/nsetcustomcolorend
		{
			/_nCustomColorSD null pt
		}def
	}ifelse
}def
/initializeSinglePassSeps{
	/_decodeNorm	[0 1] pt
	/_decodeInvert 	[1 0] pt
	/spotConverted
	{
	 begin
			name null eq{
				false
			}{
				tintValue null eq tintImage null eq and{
					true
				}{
					_inDistiller{
						false
					}{
						false
						currentpagedevice/SeparationColorNames get{name eq or}forall
						not
					}ifelse
				}ifelse
			}ifelse
	 end
	}def
	/dictImage
	{
		20 dict dup begin
			/Dict xd
			/Decode xd
			/DataSource xd
			/ImageMatrix xd
			/BitsPerComponent xd
			/Height xd
			/Width xd
			/ImageType 1 def
			Dict
	 end
		/_image load 1 execImage
	}def
	/bwImage{
	 begin
			gsave
			currentoverprint{
				blackInk{
					[/Separation /Black /DeviceGray{}] setcolorspace
					_decodeInvert dictImage
				}{
					5 npop
				}ifelse
			}{
				/DeviceGray setcolorspace
				_decodeNorm dictImage
			}ifelse
			grestore
	 end
	}def
	/ncolorimage where{
		pop
	}{
		/ncolorimage{
		 begin
				renderCMYK{
					cyanInk 
					magentaInk and
					yellowInk and
					blackInk and
					not
					currentoverprint 
					and{	
						pop pop
						gsave
						cyanInk{
							8 copy
							[/Separation /Cyan /DeviceGray{}] setcolorspace
							3 npop
							_decodeNorm dictImage
						}if
						magentaInk{
							8 copy
							[/Separation /Magenta /DeviceGray{}] setcolorspace
							4 -1 roll
							3 npop
							_decodeNorm dictImage
						}if
						yellowInk{
							8 copy
							[/Separation /Yellow /DeviceGray{}] setcolorspace
							4 -2 roll
							3 npop
							_decodeNorm dictImage
						}if
						blackInk{
							4 -3 roll
							[/Separation /Black /DeviceGray{}] setcolorspace
							3 npop
							_decodeNorm dictImage
						}{
							8 npop
						}ifelse
						grestore
					}{
						/_colorimage load 10 execImage
					}ifelse
				}{
					6 npop
					gsave
					spot1 begin
						name null ne tintImage null ne and{
							[/Separation name /DeviceGray{}] setcolorspace
							4 copy
							tintImage 
							name /Black eq{
								_decodeNorm
							}{
								_decodeInvert
							}ifelse 
							dictImage
						}{
							1 setgray fill
						}ifelse
				 end
					spot2 begin
						true setoverprint
						name null ne tintImage null ne and{
							[/Separation name /DeviceGray{}] setcolorspace
							tintImage 
							name /Black eq{
								_decodeNorm
							}{
								_decodeInvert
							}ifelse 
							dictImage
						}{
							4 npop
							1 setgray fill
						}ifelse
				 end
					grestore
				}ifelse
		 end
		}def
	}ifelse
	/getRampColorSpace{
		
		/_renderCMYK _rampSD begin renderCMYK end pt
		
		_renderCMYK not{
			_rampSD begin
				[/DeviceN 
					[
					spot1 begin
						name null ne tintImage null ne and{
							name
						}if
				 end
					spot2 begin
						name null ne tintImage null ne and{
							name
						}if
				 end
					]
					_inDistiller {
						/DeviceCMYK [
							spot1 begin
								name null ne tintImage null ne and{
									spot_C spot_M spot_Y spot_K 1
								}{
									0 0 0 0 0
								}ifelse
						 end
							spot2 begin
								name null ne tintImage null ne and{
									spot_C spot_M spot_Y spot_K 2
								}{
									0 0 0 0 0
								}ifelse
						 end
							5 1 roll 6 -2 roll add
							dup 1 eq {
								pop
								8 /index cvx 1 /exch cvx /sub cvx
								9 1 /roll cvx
							}{
								2 eq {
									8 /index cvx 1 /exch cvx /sub cvx
									10 1 /roll cvx
								}if
							}ifelse
							4 1 /roll cvx 5 -2 /roll cvx
							8 /index cvx /mul cvx /exch cvx 9 /index cvx /mul cvx /add cvx 7 1 /roll cvx
							3 1 /roll cvx 4 -2 /roll cvx
							7 /index cvx /mul cvx /exch cvx 8 /index cvx /mul cvx /add cvx 6 1 /roll cvx
							2 1 /roll cvx 3 -2 /roll cvx
							6 /index cvx /mul cvx /exch cvx 7 /index cvx /mul cvx /add cvx 5 1 /roll cvx
							5 /index cvx /mul cvx /exch cvx 6 /index cvx /mul cvx /add cvx 4 1 /roll cvx
							6 -2 /roll cvx /pop cvx /pop cvx
						] cvx bind
					}{
						/DeviceCMYK {}
					}ifelse
				] setcolorspace
		 end
			/_nColorSpace currentcolorspace pt
		}if
		
		_nSamples 1 gt{ 
			/_ndx 0 pt
			[blendColor] cvx exec
		}if
		_renderCMYK{
			/_C0 [currentcolor] pt
			/_C0_Space currentcolorspace pt
		}{
			/_C0 [
				_nCustomColorSD begin
					spot1 begin 
						name null ne{
							tintValue
						}if
				 end
					spot2 begin 
						name null ne{
							tintValue
						}if
				 end
			 end
			] pt
			/_C0_Space _nColorSpace pt
		}ifelse
		
		_nSamples 1 gt{ 
			/_ndx _nSamples 1 sub pt
			[blendColor] cvx exec
		}if
		_renderCMYK{
			/_C1 [currentcolor] pt
			/_C1_Space currentcolorspace pt
		}{
			/_C1 [
				_nCustomColorSD begin
					spot1 begin 
						name null ne{
							tintValue
						}if
				 end
					spot2 begin 
						name null ne{
							tintValue
						}if
				 end
			 end
			] pt
			/_C1_Space _nColorSpace pt
		}ifelse
		
		/_rampColorSpace _C0_Space pt
		_spotColor{
			nsetcustomcolorend
		}if
	}def
}def
/initializeMultiPassSeps{
	/invertXfer{
		[
		{
			1 exch sub
		}/exec load systemdict /currenttransfer get exec /exec load
		] cvx systemdict /settransfer get exec
	}def
	/ccThrough{
		gsave
		1 setCustomColor
		currentcmykcolor
		grestore
		add add add 0 ne
	}def
	/spotConverted
	{
	 begin
			_isCMYKSep not{
				false
			}{
				name null eq{
					false
				}{
					tintValue null eq tintImage null eq and{
						true
					}{
						spot_C spot_M spot_Y spot_K name ccThrough
					}ifelse
				}ifelse
			}ifelse
	 end
	}def
	/spotChannel
	{
		_isCMYKSep{
			pop false
		}{
			/_spotDict xp
				_spotDict/name get null eq{
					false
				}{
					_spotDict/spot_C get
					_spotDict/spot_M get
					_spotDict/spot_Y get
					_spotDict/spot_K get
					_spotDict/name get
					ccThrough 
				}ifelse
		}ifelse
	}def
	/getChannelData
	{
		_isCMYKSep dup{
			pop renderCMYK
		}if
		{
			_blackPlate{
				4 1 roll 3 npop blackInk
			}{
				_yellowPlate{
					4 2 roll 3 npop yellowInk
				}{
					_magentaPlate{
						4 3 roll 3 npop magentaInk
					}{
						3 npop cyanInk
					}ifelse
				}ifelse
			}ifelse
			{
				true /nonZeroData
			}{
				true /zeroData
			}ifelse
		}{
			4 npop
			spot1/name get null ne 
			spot1 spotChannel and{
				spot1/tintImage get dup null ne{
					false /nonZeroData
				}{
					pop false /noData
				}ifelse
			}{
				spot2/name get null ne 
				spot2 spotChannel and{
					spot2/tintImage get dup null ne{
						false /nonZeroData
					}{
						pop false /noData
					}ifelse
				}{
					false /noData
				}ifelse
			}ifelse
		}ifelse
	}def
	/renderChannelData
	{
		/_tmp xp
		_tmp /nonZeroData ne currentoverprint and{
			pop
			_tmp /zeroData eq{pop}if
			4 npop
		}{
			_tmp /nonZeroData eq{
				{
					invertXfer
				}if
					systemdict/image
				get 5 execImage
			}{
				pop
				_tmp /zeroData eq{pop}if
				4 npop
				knockOut
			}ifelse
		}ifelse
	}def
	/bwImage{
	 begin
			gsave
			dup dup dup
			getChannelData
			exch pop false exch
			renderChannelData
			grestore
	 end
	}def
	/ncolorimage{
	 begin
			pop pop
			gsave
			spot2/name get null ne spot2 spotChannel and{
				true setoverprint
			}if
			getChannelData 
			renderChannelData
			grestore
	 end
	}def
	/getRampColorSpace{
		
		/_renderCMYK _rampSD begin renderCMYK end pt
		
		_nSamples 1 gt{ 
			/_ndx 0 pt
			[blendColor] cvx exec
		}if
		
		_renderCMYK{
			/_C0 [currentcolor] pt
			/_C0_Space currentcolorspace pt
		}{
			/_C0 [
				_nCustomColorSD begin
					0
					spot1 begin 
						name null ne
						tintValue null ne and
						spot1 spotChannel and{
							pop tintValue
						}if
				 end
					spot2 begin 
						name null ne
						tintValue null ne and
						spot2 spotChannel and{
							pop tintValue
						}if
				 end
					1 exch sub
			 end
			] pt
			/_C0_Space /DeviceGray pt
		}ifelse
		
		_nSamples 1 gt{ 
			/_ndx _nSamples 1 sub pt
			[blendColor] cvx exec
		}if
		
		_renderCMYK{
			/_C1 [currentcolor] pt
			/_C1_Space currentcolorspace pt
		}{
			/_C1 [
				_nCustomColorSD begin
					0
					spot1 begin 
						name null ne
						tintValue null ne and
						spot1 spotChannel and{
							pop tintValue
						}if
				 end
					spot2 begin 
						name null ne
						tintValue null ne and
						spot2 spotChannel and{
							pop tintValue
						}if
				 end
					1 exch sub
			 end
			] pt
			/_C1_Space /DeviceGray pt
		}ifelse
		
		/_rampColorSpace _C0_Space pt
		_spotColor{
			nsetcustomcolorend
		}if
	}def
}def
end
end
defaultpacking setpacking
%%EndResource
%%BeginResource: procset AGM_Gradient 1.0 0
%%Title: (AGM Gradient Procset)
%%Version: 1.0 0
%%CreationDate: (4/26/96) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
userdict /defaultpacking currentpacking put true setpacking
userdict /AGM_Gradient 20 dict dup begin put
/AGM_Gradient_private 201 dict def
/initialize
{
	AGM_Gradient begin
	AGM_Gradient_private begin
	initializeVars
	
	/bd systemdict/mark get def
	/ed
		_level2PS 
		{
			(>>)
		}{
			(counttomark 2 idiv dup dict begin {def} repeat pop currentdict end)
		} ifelse
	cvx def
	
	_level2PS{
		initializeLev2
	}{
		initializeLev1
	}ifelse
	
	queryDevice
	
	initializeRectFill
	initializeShading
	initializeOps
	_producingSeps{
		AGM_Gradient_Sep/initialize get exec
	}{
		initializeComposite
	}ifelse
	_illustrator{
		/f{}def
		/F{}def
		/s{}def
		/S{}def
		/b{}def
		/B{}def
	}if
	/image where{
		/image get /_image xd
	}if
	/colorimage where{
		/colorimage get /_colorimage xd
	}if
	AGM_Gradient_private
	{
		dup xcheck 1 index type /arraytype eq and
		{
			bind
		}if
		pop pop
	}forall
	AGM_Gradient
	{
		dup xcheck 1 index type /arraytype eq and
		{
			bind
		}if
		pop pop
	}forall
 end
	
	currentdict readonly pop
 end
}def
/initializeAI
{
	pop pop 
	AGM_Gradient/AGM_Gradient_private get /_illustrator true put
	AGM_Gradient/initialize get exec
		AGM_Gradient begin
}def
/unload{
	systemdict/languagelevel known{
		systemdict/languagelevel get 2 ge{
			userdict/AGM_Gradient_Sep 2 copy known{
				undef
			}{
				pop pop
			}ifelse
			userdict/AGM_Gradient 2 copy known{
				undef
			}{
				pop pop
			}ifelse
		}if
	}if
}def
/terminate{
	currentdict AGM_Gradient eq{
	 end
	}if
}def
 
AGM_Gradient_private begin
/initializeVars{
	/_d255 256 array def
	0 1 255{
		_d255 exch dup 255 div put
	}bind for
	/_d255- 256 array def
	0 1 255{
		_d255- exch 1 _d255 2 index get sub put
	}bind for
	/_sSave nd
	/_dUserSpace matrix defaultmatrix def
	/_bUMatrix matrix def
	/_imageMatrix matrix def
	/_saveMatrix matrix def
	/_xm matrix def
	/_ccAry1 5 array def
	/_bbox 4 array pt
	/_level2PS 
		systemdict/languagelevel known dup{
			pop systemdict/languagelevel get 2 ge
		}if
	def
	/_level3PS
		_level2PS systemdict/shfill known and
	def
	currentdict /_illustrator known not{
		/_illustrator false def
	}if
	
}def
/initializeOps
{
	AGM_Gradient begin
	currentdict/Bc known not{
		/Bc{
		
			_renderFlag 2 eq _enabledSmoothShade or{
				6 npop
			}{
				pushBSpace
				_rampIndex 0 eq{
					pop pop
					setCStop
				}if
				linealFill
				popBSpace
			}ifelse
		
		}def
	}if
	
	currentdict/Bg known not{
		/Bg{
			10 npop
			/_gradName xp
			/_renderFlag xp
			/_enabledSmoothShade false pt
		
			_renderFlag 2 ne{
		
				_illustrator{
					_of setoverprint
				}if
		
				/_enabledSmoothShade 
					_level3PS{
						_usingSmoothShade
						_producingSeps not
						currentoverprint not or and
						_noImage not and
					}{
						false
					}ifelse
				pt
				
				_illustrator _eo and _renderFlag 3 eq or{
					eoclip
				}{
					clip
				}ifelse
		
				_gradNames _gradName 2 copy known{
					get
					mark exch aload pop
					/_gradType xp
					1 sub dup /_rampIndex xp
					/_maxRampIndex xp
					mark exch aload pop
					0 0
				}if
				pop pop
				getRampData
			}{
				mark mark
			}ifelse
		}def
	}if
	
	currentdict/Bm known not{
		/Bm{
			_renderFlag 2 ne{
				_gradType 0 eq{
					linealRamp
				}{
					radialGrad
				}ifelse
			}{
				6 npop
			}ifelse
		}def
	}if
	
	currentdict/Bh known not{
		/Bh{
			2 npop
			/_yHi xp
			/_xHi xp
			/_radHilite _xHi 0 ne _yHi 0 ne or pt
		}def
	}if
	
	currentdict/Bn known not{
		/Bn{
			AGM_Gradient_private begin
				dict /_gradNames xp
		 end
		}def
	}if
	
	currentdict/Bd known not{
		/Bd{
			AGM_Gradient begin
			AGM_Gradient_private begin
				/_nColorsBd xp
				/_gradType xp
				/_gradName xp
		}def
	}if
	
	currentdict/BD known not{
		/BD{
				currentdict/_gradNames known not{
					/_gradNames 20 dict def
				}if
				] _nColorsBd _gradType
				]  _gradName exch /_gradNames xput
		 end
		 end
		}def
	}if
	
	currentdict/Bb known not{
		/Bb{
		
			AGM_Gradient/AGM_Gradient_private get /_illustrator get not{
				AGM_Gradient begin
			}if
			AGM_Gradient_private begin
			_producingSeps{
				AGM_Gradient_Sep/AGM_Gradient_Sep_private get begin
			}if
			mySave
		}def
	}if
	
	currentdict/BB known not{
		/BB{
		
			/_tmp xp
			cleartomark cleartomark
		
			_tmp dup
			_renderFlag
		
			myRestore
		
			_producingSeps{
			 end
			}if
		
			_illustrator dup
		 end
			not {
			 end
			}if
		
			{
				2 ne exch 0 gt and{
					2 eq{
						s
					}{
						S
					}ifelse
				}{
					pop newpath
				}ifelse
			}{
				pop newpath
			}ifelse
		
		
		}def
	}if
	
	currentdict/Xm known not{
		/Xm{
			_xm astore pop
		}def
	}if
	
 end
}def
/queryDevice{
	/_inDistiller
		systemdict /currentdistillerparams known
	def
	/_inRipSep
		_level2PS{
			currentpagedevice/Separations 2 copy known{
				get
			}{
				pop pop false
			}ifelse
		}{
			false
		}ifelse
		_inDistiller or
	def
	/_noImage /lv1Fix where{
		pop lv1Fix
	}{
		false
	}ifelse
	def
	/_useShells where{
		/_useShells get /_usingShells xp
	}{
		/_usingShells false def
	}ifelse
	
	/_useSmoothShade where{
		pop
	}{
		/_useSmoothShade false def 
	}ifelse
	/_forceToCMYK where{
		pop
	}{
		/_forceToCMYK false def 
	}ifelse
	/_cyanPlate 1 0 0 0 testCMYKColorThrough def
	/_magentaPlate 0 1 0 0 testCMYKColorThrough def
	/_yellowPlate 0 0 1 0 testCMYKColorThrough def
	/_blackPlate 0 0 0 1 testCMYKColorThrough def
	/_compositeJob
		_cyanPlate _magentaPlate and _yellowPlate and _blackPlate and
	def
	/_isCMYKSep
		_cyanPlate _magentaPlate or _yellowPlate or _blackPlate or
	def
	/_compositeSpotDevice where{
		pop
	}{
		/_compositeSpotDevice _compositeJob not _inRipSep or{
			1
		}{
			0
		}ifelse
		def
	}ifelse
	/_producingSeps _compositeSpotDevice 0 ne def
	/_deviceDPI 72 0 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt def
	/_dpiThreshold where{
		pop
	}{
		/_dpiThreshold 600 def
	}ifelse
	/_screenFreqThreshold where{
		pop
	}{
		/_screenFreqThreshold 150 def
	}ifelse
	/_contoneDevice where{
		pop
	}{
		/_contoneDevice false def
	}ifelse
	/_subSampleOK 
		_deviceDPI _dpiThreshold le 
		currentScreenFreq _screenFreqThreshold le and 
		_contoneDevice not and 
	def
}def
/initializeRectFill{
	/rectfill where dup{
		exch pop not _producingSeps or
	}{
		not
	}ifelse
	{
		/rectfill{
			gsave
			newpath
			4 2 roll moveto
			1 index 0 rlineto
			0 1 index rlineto
			1 index neg 0 rlineto
			pop pop
			closepath
			fill
			grestore
		}def
	}if
}def
/initializeLev1{
	/currentScreenFreq{
		currentscreen pop pop
	}def
	/_byte 1 string def
	/colorimage where{
		pop
	}{
		/colorimage{
			pop pop
			/_blackTmp xp
			/_yellowTmp xp
			/_magentaTmp xp
			/_cyanTmp xp
			/_cnt 0 pt
			[
			_byte dup 0
			_cyanTmp 
				/_cnt cvx /get cvx _d255 /exch cvx /get cvx .3 /mul cvx
			_magentaTmp
				/_cnt cvx /get cvx _d255 /exch cvx /get cvx .59 /mul cvx
			_yellowTmp
				/_cnt cvx /get cvx _d255 /exch cvx /get cvx .11 /mul cvx
			_blackTmp 
				/_cnt cvx /get cvx _d255 /exch cvx /get cvx
			/add cvx /add cvx /add cvx 1 /exch cvx /sub cvx
			/dup cvx 0 /lt cvx{
				pop 0
			}/if cvx
			/dup cvx 1 /gt cvx{
				pop 1
			}/if cvx
			255 /mul cvx /cvi cvx
			256 /mod cvx
			/dup cvx 0 /lt cvx{
				pop 0
			}/if cvx
			/put cvx
			/_cnt dup cvx 1 /add cvx /pt cvx
			] cvx
			bind
			/_image load 5 execImage
		}def
	}ifelse
}def
/initializeLev2{
	/level2ScreenFreq{
	 begin
		60
		HalftoneType 1 eq{
			pop Frequency
		}if
		HalftoneType 2 eq{
			pop GrayFrequency
		}if
		HalftoneType 5 eq{
			pop Default level2ScreenFreq
		}if
		 end
	}def
	/currentScreenFreq{
		currenthalftone level2ScreenFreq
	}def
}def
/initializeShading{
	_useSmoothShade _level3PS and{
		/_usingSmoothShade true pt
		initializeLev3_Ops
	}{
		/_usingSmoothShade false pt
	}ifelse
}def
/initializeLev3_Ops
{
	/initShFill{
		/_index _gradType 0 eq {0}{_maxRampIndex 1 sub} ifelse pt
		/_rampFuncsArray _maxRampIndex array pt
		/_boundsArray _maxRampIndex 1 sub array pt
		/_encodeArray _maxRampIndex 2 mul array pt
		/_beginCoord _rampPoint pt
		/_colorSpace null pt
		/_firstFill _rampIndex _maxRampIndex eq pt
		/_lastFill false pt
	}def
	/linealShFill{
		popBSpace
		_xm aload pop pushBSpace
		
		/_size _index 1 add pt
		_size _maxRampIndex lt {
			/_rampFuncsArray _rampFuncsArray 0 _size getinterval pt
			/_boundsArray _boundsArray 0 _size 1 sub getinterval pt
			/_encodeArray _encodeArray 0 _size 2 mul getinterval pt
		}if
		
		bd
			/ShadingType 2
			/ColorSpace _colorSpace
			_rgbInCMYK{
				/Function [
					_cData sampFunc
					_mData sampFunc
					_yData sampFunc
					_kData sampFunc
				]
			}{
				/Function 
					bd
						/FunctionType 3
						/Domain [0 1]
						/Functions _rampFuncsArray
						/Bounds _boundsArray
						/Encode _encodeArray
					ed
			}ifelse
			/Extend [_firstFill _lastFill]
			/Domain [0 1] 
			/Coords [_beginCoord 0 _endCoord 0]
		ed
		shfill
	}def
	
	/radialShFill{
		/_size _maxRampIndex _index sub pt
		_size _maxRampIndex lt {
			/_rampFuncsArray _rampFuncsArray _index _size getinterval pt
			/_boundsArray _boundsArray _index _size 1 sub getinterval pt
			/_encodeArray _encodeArray _index 2 mul _size 2 mul getinterval pt
		}if
		
		/_rampLen _beginCoord _endCoord sub pt
		bd
			/ShadingType 3
			/ColorSpace _colorSpace
			_rgbInCMYK{
				/Function [
					_cData sampFunc
					_mData sampFunc
					_yData sampFunc
					_kData sampFunc
				]
			}{
				/Function 
					bd
						/FunctionType 3
						/Domain [0 1]
						/Functions _rampFuncsArray
						/Bounds _boundsArray
						/Encode _encodeArray
					ed
			}ifelse
			/Extend [_lastFill _firstFill]
			/Domain [0 1] 
			/Coords [_xHi _rampLen mul _yHi _rampLen mul _endCoord 0 0 _beginCoord] 
		ed
		shfill
		
		_radHilite{
			_xHi _rampLen mul _yHi _rampLen mul translate
		}if
	}def
	
	%
	/sampFunc{
		/_tmp exch pt
		bd
			_tmp length 1 eq {
				_tmp 0 get
				/_tmp 2 string pt
				dup _tmp 0 3 -1 roll put
				_tmp 1 3 -1 roll put
			}if
			/FunctionType 0
			/Order 1
			/Size [_tmp length]
			/Domain [0 1]
			/BitsPerSample 8
			/DataSource _tmp
			/Range [0 1]
		ed
	}def
	
	/fillRamp{
	
	
		/_invert _midPoint 0.5 lt pt
		_rampIndex _maxRampIndex eq {
			initShFill
		}if
		
		getRampColorSpace
		
		_colorSpace null eq{
			/_colorSpace _rampColorSpace pt
		}{
			_colorSpace _rampColorSpace ne _rgbInCMYK or{
				/_index _index 1 
				_gradType 0 eq{
					sub pt
					linealShFill
				}{
					add pt
					radialShFill
				}ifelse
				initShFill
				/_colorSpace _rampColorSpace pt
			} if
		}ifelse
		/_endCoord _endPoint pt	
		/_rgbInCMYK false pt
		_producingSeps _forceToCMYK or _rgbRamp and {
			_spotColor{
				_renderCMYK
			}{
				_isCMYKSep
			}ifelse
		}{
			false
		}ifelse
		{
			_compositeJob{
				/_rgbInCMYK true pt
				_cyanData _magentaData _yellowData _blackData _nSamples 4 expandColor
				dup length string copy /_kData exch pt
				dup length string copy /_yData exch pt
				dup length string copy /_mData exch pt
				dup length string copy /_cData exch pt
			}{
				_rampFuncsArray _index
					_cyanPlate{_cyanData}if
						_magentaPlate{_magentaData}if
						_yellowPlate{_yellowData}if
						_blackPlate{_blackData}if
					_nSamples expandOne
					sampFunc
					dup begin /Decode [1 0] def end
				put
				/_invert false pt
			}ifelse
		}{
			_rampFuncsArray _index
				bd
					/FunctionType 2
					/Domain [0 1]
					/N 0.5 log _invert{1 _midPoint sub}{_midPoint}ifelse log div
					_gradType 0 eq{
						_invert{/C1}{/C0}ifelse _C0
						_invert{/C0}{/C1}ifelse _C1
					}{
						_invert{/C0}{/C1}ifelse _C1
						_invert{/C1}{/C0}ifelse _C0
					}ifelse
				ed
			put
		}ifelse
		
		_rampIndex 1 ne{
			_boundsArray _index _gradType 1 eq{1 sub}if _endCoord put
		} if
		
		0 1 _invert {exch}if
		_encodeArray _index 2 mul 1 add 3 -1 roll put
		_encodeArray _index 2 mul 3 -1 roll put
		_rampIndex 1 eq {
			/_lastFill true pt
			_gradType 0 eq{
				linealShFill
			}{
				radialShFill
			}ifelse
		}if
		/_index _index 1 
		_gradType 0 eq{
			add pt
		}{
			sub pt
		}ifelse
	}def
}def
/initializeComposite{
	/bwImage{
		pop /_image load 5 execImage 
	}def
	/rampImage{
		_enabledSmoothShade{
			fillRamp
		}{
			_color{
				_nSamples setImageParms
	
				
				_rgbRamp _forceToCMYK not and{
					_redData _greenData _blueData _nSamples 3 expandColor
					true 3 null ncolorimage
				}{
					_cyanData _magentaData _yellowData _blackData _nSamples 4 expandColor
					true 4 null ncolorimage
				}ifelse
			}{
				_nSamples setImageParms _blackData null bwImage
			}ifelse
		}ifelse
	}def
	/setCStop{
		/_colorStyle exch pt
		_colorStyle 0 eq{
			1 exch sub
			0 0 0
			4 -1 roll
		}if
		
		_colorStyle 2 eq{
			_forceToCMYK{
				3 npop setcmykcolor
			}{
				setrgbcolor 4 npop
			}ifelse
		}if
		
		_colorStyle 3 eq{
			1 exch sub /_tmp xp
			pop
			4{
				_tmp mul 4 1 roll
			}repeat
		}if
		
		_colorStyle 4 eq{
			_forceToCMYK{
				6 npop setcmykcolor
			}{
				3 -1 roll pop pop
				1 exch sub /_tmp xp
				3{
					1 exch sub _tmp mul 1 exch sub 3 1 roll
				}repeat
				setrgbcolor 
				4 npop
			}ifelse
		}if
		_colorStyle 2 ne _colorStyle 4 ne and{
			null nsetcustomcolor
		}if
	}def
	/nsetcustomcolor
	{
		pop setcmykcolor
	}def
	/nsetcustomcolorend
	{
	}def
	/ncolorimage{
		pop 
		/_colorimage load 10 execImage
	}def
	_noImage not _level2PS not and{
		/linealFill{
			8 setImageParms
			_color{
				currentcmykcolor
				4{
					makeByte8 4 1 roll
				}repeat
				true 4 null ncolorimage
			}{
				currentgray makeByte8 null bwImage
			}ifelse
		}def
	}if
	/getRampColorSpace{
		_nSamples 1 gt{ 
			/_ndx 0 pt
			[blendColor] cvx exec
		}if
		/_C0 [currentcolor] pt
		/_C0_Space currentcolorspace pt
		
		_nSamples 1 gt{ 
			/_ndx _nSamples 1 sub pt
			[blendColor] cvx exec
		}if
		/_C1 [currentcolor] pt
		/_C1_Space currentcolorspace pt
		
		/_rampColorSpace _C0_Space pt
		
		_spotColor{
			nsetcustomcolorend
		}if
	}def
}def
/npop{
	{pop}repeat
}def
/xd{
	exch def
}def
/nd{
	null def
}def
/pt{
	AGM_Gradient_private 3 1 roll put
}def
/xp{
	exch pt
}def
/xput{
	dup load dup length exch maxlength eq{
		dup dup load dup
		length 2 mul dict copy def
	}if
	load begin
		def
  end
}def
/mySave{
	save /_sSave xp
}def
/myRestore{
	_sSave type /savetype eq{
		_sSave restore
	}if
}def
/gMark{
	counttomark 2 add -1 roll
}def
/execImage{
	/_tmp xp
	{
		exec
	}stopped{
		$error /errorname get /undefinedresult ne{
			stop
		}{
			_tmp npop
		}ifelse
	}if
}def
/pushBSpace{
	newpath gsave
	_bUMatrix astore concat 
}def
/popBSpace{
	grestore
}def
/makeByte8{
	/_tmp 0 pt
	255 mul cvi
	8 string 8{
		dup _tmp 3 index put 
		/_tmp _tmp 1 add pt
	}repeat
	exch pop
}def
/setImageParms{
	1 8 2 index 0 0 1 0 0 _imageMatrix astore
}def
/linealFill{
	0 0 1 1 rectfill
}def
/testCMYKColorThrough{
	gsave
	setcmykcolor currentcmykcolor
	grestore
	add add add 0 ne
}def
/expandOne	{
	/_tmp xp
	dup type /stringtype ne{
		_tmp string
		exch
		dup 0 ne{
			255 mul cvi
			0 1 _tmp 1 sub{
				3 copy
				exch put pop
			}for
		}if
		pop
	}if
}def
/expandColor{
	/_channels xp
	/_len xp
	_channels{
		_len expandOne _channels 1 roll
	}repeat
}def
/blendColor{
	
	_color{
		_rgbRamp _producingSeps not and _forceToCMYK not and{
			_redData dup type /stringtype eq{
				/_ndx cvx /get cvx _d255 /exch cvx /get cvx
			}if
			_greenData dup type /stringtype eq{
				/_ndx cvx /get cvx _d255 /exch cvx /get cvx
			}if
			_blueData dup type /stringtype eq{
				/_ndx cvx /get cvx _d255 /exch cvx /get cvx
			}if
			/setrgbcolor cvx
		}{
			_cyanData dup type /stringtype eq{
				/_ndx cvx /get cvx _d255 /exch cvx /get cvx
			}if
			_magentaData dup type /stringtype eq{
				/_ndx cvx /get cvx _d255 /exch cvx /get cvx
			}if
			_yellowData dup type /stringtype eq{
				/_ndx cvx /get cvx _d255 /exch cvx /get cvx
			}if
			_blackData dup type /stringtype eq{
				/_ndx cvx /get cvx _d255 /exch cvx /get cvx
			}if
	
			_spotColor{
				_rampSD begin
					/_rampSD cvx /begin cvx
	
					spot1 begin
						tintImage dup type /stringtype eq{
							/_ndx cvx /get cvx _d255- /exch cvx /get cvx
						}{
							dup null ne{
								name type /nametype ne{
									1 exch sub
								}if
							}if
						}ifelse
				 end
					/spot1 cvx /tintValue 3 -1 /roll cvx /put cvx
	
					spot2 begin
						tintImage dup type /stringtype eq{
							/_ndx cvx /get cvx _d255- /exch cvx /get cvx
						}{
							dup null ne{
								name type /nametype ne{
									1 exch sub
								}if
							}if
						}ifelse
				 end
					/spot2 cvx /tintValue 3 -1 /roll cvx /put cvx
					/end cvx
			 end
				/_rampSD cvx
				/nsetcustomcolor cvx
			}{
				/setcmykcolor cvx
			}ifelse
		}ifelse
	}{
		_blackData dup type /stringtype eq{
			/_ndx cvx /get cvx _d255 /exch cvx /get cvx
		}if
		
		_enabledSmoothShade{
			1 /exch cvx /sub cvx 0 0 0 4 -1 /roll cvx /setcmykcolor cvx
		}{
			 /setgray cvx
		}ifelse
	}ifelse
}def
/useRectImage{
	_subSampleOK _enabledSmoothShade not and{
		{
			mark
			0 1 dtransform atan cvi 90 mod 0 eq
			1 0 dtransform atan cvi 90 mod 0 eq
		} stopped
		{
			cleartomark
			false
		}
		{
			and exch pop
		} ifelse
	}{
		false
	}ifelse
}def
/linealImage{
	_noImage{
		rectImage
	}{
		_producingSeps{
				AGM_Gradient_Sep/AGM_Gradient_Sep_private get
				/rampImage get exec
		}{
			useRectImage{
				rectImage
			}{
				rampImage
			}ifelse
		}ifelse
	}ifelse
}def
/linealRamp{
	pushBSpace
	_ramp{
		linealImage
	}{
		linealFill
	}ifelse
	popBSpace
	/_rampIndex _rampIndex 1 sub pt
	_rampIndex 0 gt{
		getRampData
	}if
}def
/radialGrad{
	/_usingShells currentoverprint _producingSeps and _usingShells or pt
	/_firstShell true pt
	_enabledSmoothShade not{
		currentoverprint _producingSeps and{
			
			newpath
			clippath pathbbox 
			1 add 4 1 roll
			1 add 4 1 roll
			1 sub 4 1 roll
			1 sub 4 1 roll
			_bbox astore pop
			
			newpath
			_bbox 0 get _bbox 1 get moveto
			_bbox 2 get _bbox 1 get lineto
			_bbox 2 get _bbox 3 get lineto
			_bbox 0 get _bbox 3 get lineto
			closepath
			6 copy
			gsave _bUMatrix astore concat
			1 0 moveto 0 0 1 0 360 arc closepath
			eoclip fill
			popBSpace
		}{
			fill
		}ifelse
	}if
	pushBSpace
	
	_radHilite{
		_xHi _yHi _bUMatrix idtransform /_yHi xp /_xHi xp
		_rampPoint 1 lt{
			1 _rampPoint sub dup _xHi mul exch _yHi mul translate
		}if
	}if
	_rampIndex{
		radialRamp
		/_rampIndex _rampIndex 1 sub pt
		_rampIndex 0 gt{
			getRampData
		}if
	}repeat
	
	popBSpace
	
}def
/getNSamples{
	0 exch
	{
		dup type /stringtype eq{
			length exch pop exit
		}if
		pop
	}forall
	dup 0 eq{
		pop 1
	}if
}def
/getRampData{
	/_rampType gMark pt
	/_color _rampType 0 gt pt
	/_ccRGB _rampType 5 eq _rampType 6 eq or pt
	/_rgbRamp _rampType 4 eq _ccRGB or pt
	/_ccProcess _rampType 2 eq _rampType 3 eq or pt
	_producingSeps{
		_rampSD initSpotDict
		/_spotColor _ccProcess _ccRGB or pt
	}{
		/_spotColor false pt
	}ifelse
	/_ramp true pt
	100 div /_rampPoint xp
	100 div /_midPoint xp
	
	dup /_colorStyle xp
	_colorStyle 0 eq{ 
		2
	}{
		_colorStyle 1 eq{ 
			5
		}{
			_colorStyle 2 eq{
				8
			}{
				_colorStyle 3 eq{
					_producingSeps{
						_rampSD /spot1 get begin
							/name 3 index def
							/spot_K 4 index def
							/spot_Y 5 index def
							/spot_M 6 index def
							/spot_C 7 index def
					 end
					}if
					7
				}{
					_producingSeps{
						_rampSD/spot1 get begin
							/name 4 index def
							/spot_K 8 index def
							/spot_Y 9 index def
							/spot_M 10 index def
							/spot_C 11 index def
					 end
					}if
					11
				} ifelse
			}ifelse
		}ifelse
	}ifelse
	/_tmp xp
	_tmp index 100 div /_endPoint xp
	
	_gradType 1 eq{
		_tmp 1 add index 100 div /_midPoint xp
	}if
	
	_producingSeps{
		_tmp 2 add index /_nextColorStyle xp
		_nextColorStyle 3 eq{
			/_tmp _tmp 4 add pt
			_tmp index dup
			_rampSD/spot1 get /name get ne{
				_rampSD /spot2 get begin
					/name xd
					/spot_K _tmp 2 add index def
					/spot_Y _tmp 3 add index def
					/spot_M _tmp 4 add index def
					/spot_C _tmp 5 add index def
			 end
			}{
				pop
			}ifelse
		}if
		_nextColorStyle 4 eq{
			/_tmp _tmp 5 add pt
			_tmp index dup
			_rampSD/spot1 get /name get ne{
				_rampSD /spot2 get begin
					/name xd
					/spot_K _tmp 5 add index def
					/spot_Y _tmp 6 add index def
					/spot_M _tmp 7 add index def
					/spot_C _tmp 8 add index def
			 end
			}{
				pop
			}ifelse
		}if
	}if
	_rampType 3 eq _rampType 6 eq or{
		/_tint2Data gMark pt
	}if
	_ccProcess _ccRGB or{
		/_tint1Data gMark pt
	}if
	_rgbRamp{
		/_blueData gMark pt
		/_greenData gMark pt
		/_redData gMark pt
	}if
	
	_producingSeps{
		_ccProcess _ccRGB or{
			_rampType 3 eq _rampType 6 eq or{
				_rampSD /spot2 get begin
					/tintImage _gradType 0 eq{
						_tint2Data
					}{
						_tint1Data
					}ifelse
					def
					name null eq{
						/name /Black def
					}if
			 end
			}if
			_rampSD /spot1 get begin
				/tintImage _gradType 0 eq _rampType 2 eq or _rampType 5 eq or{
					_tint1Data
				}{
					_tint2Data
				}ifelse
				def
				_rampType 2 eq _rampType 5 eq or{
					name null eq{
						/name _rampSD/spot2 get /name get def
						/spot_C _rampSD/spot2 get /spot_C get def
						/spot_M _rampSD/spot2 get /spot_M get def
						/spot_Y _rampSD/spot2 get /spot_Y get def
						/spot_K _rampSD/spot2 get /spot_K get def
						_rampSD/spot2 get /name null put
					}if
				}{
					name null eq{
						/name /Black def
					}if
				}ifelse
		 end
		}if
	}if
	/_blackData gMark pt
	_rampType 0 gt{
		counttomark 4 add -3 roll
		/_yellowData xp
		/_magentaData xp
		/_cyanData xp
	}if
	_ramp{
		/_nSamples
			[
			_rampType 0 eq {_blackData}if
			_rampType 1 eq {_cyanData _magentaData _yellowData _blackData}if
			_rampType 2 eq {_cyanData _magentaData _yellowData _blackData _tint1Data}if
			_rampType 3 eq {_cyanData _magentaData _yellowData _blackData _tint1Data _tint2Data}if
			_rampType 4 eq {_cyanData _magentaData _yellowData _blackData _redData _greenData _blueData}if
			_rampType 5 eq {_cyanData _magentaData _yellowData _blackData _redData _greenData _blueData _tint1Data}if
			_rampType 6 eq {_cyanData _magentaData _yellowData _blackData _redData _greenData _blueData _tint1Data _tint2Data}if
			] getNSamples pt
		_enabledSmoothShade not {/_ramp _nSamples 1 gt pt} if
	} if
	
	setCStop
}def
/rectImage{
	gsave
	/_sInc 1 pt
	/_bInc 1 _nSamples div pt
	/_nSubSamples _nSamples pt
	/_optimize false pt
		
	_subSampleOK{
		/_uRampLen 1 0 dtransform _dUserSpace idtransform dup mul exch dup mul add sqrt pt
		/_pChange _uRampLen 0 eq{0}{_nSamples _uRampLen div}ifelse pt
		
		_pChange .5 gt dup /_optimize xp{
			/_nSubSamples _uRampLen 2 div round cvi dup 1 le{pop 2}if pt
			/_bInc 1 _nSubSamples div pt
			/_sInc _nSamples 1 sub _nSubSamples 1 sub div pt
		}if
	}if
	0
	_nSubSamples
	[
	/dup cvx
	_optimize {
		/round cvx /cvi cvx
	} if
	/_ndx /exch cvx /pt cvx
	blendColor
	0 0 _bInc 1 /rectfill cvx
	_bInc 0 /translate cvx
	_sInc /add cvx
	] cvx
	bind
	repeat
	pop
	_spotColor{
		nsetcustomcolorend
	}if
	grestore
}def
/radialInit{
	/_nRadSamples _nSamples dup 0 eq{pop 1}if pt
	/_sInc -1 pt
	/_rampLen _rampPoint _endPoint sub pt
	/_bInc _rampLen _nSamples div neg pt
	/_optimize false pt
	_subSampleOK{
		/_uRampLen
			_rampLen 0 dtransform _dUserSpace idtransform dup mul exch dup mul add sqrt
			0 _rampLen dtransform _dUserSpace idtransform dup mul exch dup mul add sqrt
			2 copy lt{
				exch
			}if pop
		pt
		/_pChange 
			_uRampLen 0 eq{
				0
			}{
				_nSamples _uRampLen div
			}ifelse
		pt
		_pChange .5 gt dup /_optimize xp{
			/_nRadSamples _uRampLen 2 div round cvi dup 1 le{pop 2}if pt
			/_bInc _rampLen _nRadSamples div neg pt
			/_sInc _nSamples 1 sub _nRadSamples 1 sub div neg pt
		}if
	}if
	_radHilite{
		/_xBCInc _xHi _rampLen mul _nRadSamples div pt
		/_yBCInc _yHi _rampLen mul _nRadSamples div pt
	}if
}def
/radialRamp{
	_enabledSmoothShade{
		fillRamp
	}{
		/_saveMatrix _saveMatrix currentmatrix def
		
		radialInit
	
		%
		%
		true
		_producingSeps _rgbRamp not and{
			_nSamples 1 gt{ 
				pop
				/_ndx 0 pt
				[blendColor] cvx exec
				currentInkN
				/_ndx _nSamples 1 sub pt
				[blendColor] cvx exec
				currentInkN
				or
			}if
		}if
		{
			_rampPoint
		
			_nSamples 1 sub
		
			_nRadSamples 
			[
				/dup cvx
		
				_optimize{
					/round cvx /cvi cvx
				}if
		
				/_ndx /exch cvx /pt cvx
				
				_usingShells{
					/_firstShell cvx{
						/_firstShell false pt
					}{
						0 0 3 index 360 0 arcn fill
					}/ifelse cvx
				}if
		
				blendColor
		
				_usingShells{
					0 0 3 /index cvx 0 360 /arc cvx 
				}{
					0 0 3 /index cvx 0 360 /arc cvx /fill cvx
				}ifelse
		
				/exch cvx _bInc /add cvx /exch cvx
		
				_sInc /add cvx
		
				_radHilite{
					_xBCInc _yBCInc /translate cvx
				}if
			] cvx bind
			repeat
		
			pop pop
		}{
			_usingShells{
				0 0 _rampPoint 360 0 arcn fill
			}if
		}ifelse
	
		_saveMatrix setmatrix
		
		_radHilite{
			_xHi _rampLen mul _yHi _rampLen mul translate
		}if
		
		_usingShells _rampIndex 1 eq and{
			fill
		}if
	
		_spotColor{
			nsetcustomcolorend
		}if
	}ifelse
}def
end
end
defaultpacking setpacking
%%EndResource
%%BeginProcSet: Adobe_ColorImage_AI6 1.3 0
userdict /Adobe_ColorImage_AI6 known not
{
	userdict /Adobe_ColorImage_AI6 53 dict put 
} if
userdict /Adobe_ColorImage_AI6 get begin
/initialize { 
	Adobe_ColorImage_AI6 begin
	Adobe_ColorImage_AI6 {
		dup type /arraytype eq {
			dup xcheck {
				bind
			} if
		} if
		pop pop
	} forall
} def
/terminate { end } def
currentdict /Adobe_ColorImage_AI6_Vars known not {
	/Adobe_ColorImage_AI6_Vars 41 dict def
} if
Adobe_ColorImage_AI6_Vars begin
	/plateindex -1 def
	/_newproc null def
	/_proc1 null def
	/_proc2 null def
	/sourcearray 4 array def
	/_ptispace null def
	/_ptiname null def
	/_pti0 0 def
	/_pti1 0 def
	/_ptiproc null def
	/_ptiscale 0 def
	/_pticomps 0 def
	/_ptibuf 0 string def
	/_gtigray 0 def
	/_cticmyk null def
	/_rtirgb null def
	/XIEnable true def
	/XIType 0 def
	/XIEncoding 0 def
	/XICompression 0 def
	/XIChannelCount 0 def
	/XIBitsPerPixel 0 def
	/XIImageHeight 0 def
	/XIImageWidth 0 def
	/XIImageMatrix null def
	/XIRowBytes 0 def
	/XIFile null def
	/XIBuffer1 null def
	/XIBuffer2 null def
	/XIBuffer3 null def
	/XIDataProc null def
	/XIColorSpace /DeviceGray def
	/XIColorValues 0 def
	/XIPlateList false def
end
/ci6colorimage /colorimage where {/colorimage get}{null} ifelse def
/ci6image systemdict /image get def
/ci6curtransfer systemdict /currenttransfer get def
/ci6curoverprint /currentoverprint where {/currentoverprint get}{{_of}} ifelse def
/ci6foureq {
	4 index ne {
		pop pop pop false
	}{
		4 index ne {
			pop pop false
		}{
			4 index ne {
				pop false
			}{
				4 index eq
			} ifelse
		} ifelse
	} ifelse
} def
/ci6testplate {
	Adobe_ColorImage_AI6_Vars begin
		/plateindex -1 def
		/setcmykcolor where {
			pop
			gsave
			1 0 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 1 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 0 1 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 0 0 1 setcmykcolor systemdict /currentgray get exec 1 exch sub
			grestore
			1 0 0 0 ci6foureq { 
				/plateindex 0 def
			}{
				0 1 0 0 ci6foureq { 
					/plateindex 1 def
				}{
					0 0 1 0 ci6foureq {
						/plateindex 2 def
					}{
						0 0 0 1 ci6foureq { 
							/plateindex 3 def
						}{
							0 0 0 0 ci6foureq {
								/plateindex 5 def
							} if
						} ifelse
					} ifelse
				} ifelse
			} ifelse
			pop pop pop pop
		} if
		plateindex
 end
} def
/ci6concatprocs {
	/packedarray where {
		pop dup type /packedarraytype eq 2 index type
		/packedarraytype eq or
	}{
		false
	} ifelse
	{
		/_proc2 exch cvlit def
		/_proc1 exch cvlit def
		_proc1 aload pop
		_proc2 aload pop
		_proc1 length
		_proc2 length add
		packedarray cvx
	}{
		/_proc2 exch cvlit def
		/_proc1 exch cvlit def
		/_newproc _proc1 length _proc2 length add array def
		_newproc 0 _proc1 putinterval
		_newproc _proc1 length _proc2 putinterval
		_newproc cvx
	} ifelse
} def
/ci6istint {
	type /arraytype eq 
} def
/ci6isspot {
	dup type /arraytype eq {
		dup length 1 sub get /Separation eq
	}{
		pop false
	} ifelse
} def
/ci6spotname {
	dup ci6isspot {dup length 2 sub get}{pop ()} ifelse
} def
/ci6altspace {
	aload pop pop pop ci6colormake
} def
/ci6numcomps {
	dup /DeviceGray eq {
		pop 1
	}{
		dup /DeviceRGB eq {
			pop 3
		}{
			/DeviceCMYK eq {
				4
			}{
				1
			} ifelse
		} ifelse
	} ifelse
} def
/ci6marksplate {
	dup /DeviceGray eq {
		pop plateindex 3 eq
	}{
		dup /DeviceRGB eq {
			pop plateindex 5 ne
		}{
			dup /DeviceCMYK eq {
				pop plateindex 5 ne
			}{
				dup ci6isspot {
					/findcmykcustomcolor where {
						pop
						dup length 2 sub get
						0.1 0.1 0.1 0.1 5 -1 roll
						findcmykcustomcolor 1 setcustomcolor
						systemdict /currentgray get exec
						1 ne
					}{
						pop plateindex 5 ne
					} ifelse
				}{
					pop plateindex 5 ne
				} ifelse
			} ifelse
		} ifelse
	} ifelse
} def
/ci6colormake {
	dup ci6numcomps
	exch 1 index 2 add 1 roll
	dup 1 eq {pop}{array astore} ifelse
	exch
} def
/ci6colorexpand {
	dup ci6spotname exch
	dup ci6istint {
		ci6altspace
		exch 4 1 roll
	}{
		1 3 1 roll
	} ifelse
} def
/ci6colortint {
	dup /DeviceGray eq {
		3 1 roll 1 exch sub mul 1 exch sub exch
	}{
		dup /DeviceRGB eq {
			3 1 roll {1 exch sub 1 index mul 1 exch sub exch} forall pop 3 array astore exch
		}{
			dup /DeviceCMYK eq {
				3 1 roll {1 index mul exch} forall pop 4 array astore exch
			}{
				3 1 roll mul exch
			} ifelse
		} ifelse
	} ifelse
} def
/ci6colortocmyk {
	dup /DeviceGray eq {
		pop 1 exch sub 0 0 0 4 -1 roll 4 array astore
	}{
		dup /DeviceRGB eq {
			pop aload pop _rgbtocmyk 4 array astore
		}{
			dup /DeviceCMYK eq {
				pop
			}{
				ci6altspace ci6colortint ci6colortocmyk
			} ifelse
		} ifelse
	} ifelse
} def
/ci6makeimagedict {
	7 dict begin
		/ImageType 1 def
		/Decode exch def
		/DataSource exch def
		/ImageMatrix exch def
		/BitsPerComponent exch def
		/Height exch def
		/Width exch def
	currentdict end
} def
/ci6stringinvert {
	0 1 2 index length 1 sub {
		dup 2 index exch get 255 exch sub 2 index 3 1 roll put
	} for
} def
/ci6stringknockout {
	0 1 2 index length 1 sub {
		255 2 index 3 1 roll put
	} for
} def
/ci6stringapply {
	0 1 4 index length 1 sub {
		dup
		4 index exch get
		3 index 3 1 roll
		3 index exec
	} for
	pop exch pop
} def
/ci6walkrgbstring {
	0 3 index
	dup length 1 sub 0 3 3 -1 roll {
		3 getinterval {} forall
		5 index exec
		3 index
	} for
	
	 5 {pop} repeat
} def
/ci6walkcmykstring
{
	0 3 index
	dup length 1 sub 0 4 3 -1 roll {
		4 getinterval {} forall
		
		6 index exec
		
		3 index
		
	} for
	
	5 { pop } repeat
	
} def
/ci6putrgbtograystr
{
	.11 mul exch
	
	.59 mul add exch
	
	.3 mul add
	
	cvi 3 copy put
	
	pop 1 add
} def
/ci6putcmyktograystr
{
	exch .11 mul add
	
	exch .59 mul add
	
	exch .3 mul add
	
	dup 255 gt { pop 255 } if
	
	255 exch sub cvi 3 copy put
	
	pop 1 add
} def
/ci6rgbtograyproc {	
	Adobe_ColorImage_AI6_Vars begin 
		sourcearray 0 get exec
		XIBuffer3
		dup 3 1 roll 
		
		/ci6putrgbtograystr load exch
		ci6walkrgbstring
 end
} def
/ci6cmyktograyproc {	
	Adobe_ColorImage_AI6_Vars begin
		sourcearray 0 get exec
		XIBuffer3
		dup 3 1 roll 
		
		/ci6putcmyktograystr load exch
		ci6walkcmykstring
 end
} def
/ci6separatecmykproc {	
	Adobe_ColorImage_AI6_Vars begin
		sourcearray 0 get exec
		
		XIBuffer3
		
		0 2 index
		
		plateindex 4 2 index length 1 sub {
			get 255 exch sub
			
			3 copy put pop 1 add
			
			2 index
		} for
		pop pop exch pop
 end
} def
	
/ci6compositeimage {
	dup 1 eq {
		pop pop image
	}{
		/ci6colorimage load null ne {
			ci6colorimage
		}{
			3 1 roll pop
			sourcearray 0 3 -1 roll put
			3 eq {/ci6rgbtograyproc}{/ci6cmyktograyproc} ifelse load
			image
		} ifelse
	} ifelse
} def
/ci6knockoutimage {
	gsave
	0 ci6curtransfer exec 1 ci6curtransfer exec
	eq {
		0 ci6curtransfer exec 0.5 lt
	}{
		0 ci6curtransfer exec 1 ci6curtransfer exec gt
	} ifelse
	{{pop 0}}{{pop 1}} ifelse
	systemdict /settransfer get exec
	ci6compositeimage
	grestore
} def
/ci6drawimage {
	ci6testplate -1 eq {
		pop ci6compositeimage
	}{
		dup type /arraytype eq {
			dup length plateindex gt {plateindex get}{pop false} ifelse
		}{
			{
				true
			}{
				dup 1 eq {plateindex 3 eq}{plateindex 3 le} ifelse
			} ifelse
		} ifelse
		{
			dup 1 eq {
				pop pop ci6image
			}{
				dup 3 eq {
					ci6compositeimage
				}{
					pop pop
					sourcearray 0 3 -1 roll put
					/ci6separatecmykproc load
					ci6image
				} ifelse
			} ifelse
		}{
			ci6curoverprint {
				7 {pop} repeat
			}{
				ci6knockoutimage
			} ifelse
		} ifelse
	} ifelse
} def
/ci6proctintimage {
	/_ptispace exch store /_ptiname exch store /_pti1 exch store /_pti0 exch store /_ptiproc exch store
	/_pticomps _ptispace ci6numcomps store
	/_ptiscale _pti1 _pti0 sub store
	level2? {
		_ptiname length 0 gt version cvr 2012 ge and {
			[/Separation _ptiname _ptispace {_ptiproc}] setcolorspace
			[_pti0 _pti1] ci6makeimagedict ci6image
		}{
			[/Indexed _ptispace 255 {255 div _ptiscale mul _pti0 add _ptiproc}] setcolorspace
			[0 255] ci6makeimagedict ci6image
		} ifelse
	}{
		_pticomps 1 eq {
			{
				dup
				{
					255 div _ptiscale mul _pti0 add _ptiproc 255 mul cvi put
				} ci6stringapply
			} ci6concatprocs ci6image
		}{
			{
				dup length _pticomps mul dup _ptibuf length ne {/_ptibuf exch string store}{pop} ifelse
				_ptibuf {
					exch _pticomps mul exch 255 div _ptiscale mul _pti0 add _ptiproc
					_pticomps 2 add -2 roll
					_pticomps 1 sub -1 0 {
						1 index add 2 index exch
						5 -1 roll
						255 mul cvi put
					} for
					pop pop
				} ci6stringapply
			} ci6concatprocs false _pticomps
			/ci6colorimage load null eq {7 {pop} repeat}{ci6colorimage} ifelse
		} ifelse
	} ifelse
} def
/ci6graytintimage {
	/_gtigray 5 -1 roll store
	{1 _gtigray sub mul 1 exch sub} 4 1 roll
	/DeviceGray ci6proctintimage
} def
/ci6cmyktintimage {
	/_cticmyk 5 -1 roll store
	{_cticmyk {1 index mul exch} forall pop} 4 1 roll
	/DeviceCMYK ci6proctintimage
} def
/ci6rgbtintimage {
	/_rtirgb 5 -1 roll store
	{_rtirgb {1 exch sub 1 index mul 1 exch sub exch} forall pop} 4 1 roll
	/DeviceRGB ci6proctintimage
} def
/ci6tintimage {
	ci6testplate -1 eq {
		ci6colorexpand
		3 -1 roll 5 -1 roll {0}{0 exch} ifelse 4 2 roll
		dup /DeviceGray eq {
			pop ci6graytintimage
		}{
			dup /DeviceRGB eq {
				pop ci6rgbtintimage
			}{
				pop ci6cmyktintimage
			} ifelse
		} ifelse
	}{
		dup ci6marksplate {
			plateindex 5 lt {
				ci6colortocmyk plateindex get
				dup 0 eq ci6curoverprint and {
					7 {pop} repeat
				}{
					1 exch sub
					exch {1 0}{0 1} ifelse () ci6graytintimage
				} ifelse
			}{
				pop exch {0}{0 exch} ifelse 0 3 1 roll () ci6graytintimage
			} ifelse
		}{
			ci6curoverprint {
				8 {pop} repeat
			}{
				pop pop pop
				{pop 1} 0 1 () /DeviceGray ci6proctintimage
			} ifelse
		} ifelse
	} ifelse
} def
/XINullImage {
} def
/XIImageMask {
	XIImageWidth XIImageHeight false
	[XIImageWidth 0 0 XIImageHeight neg 0 0]
	/XIDataProc load
	imagemask
} def
/XIImageTint {
	XIImageWidth XIImageHeight XIBitsPerPixel
	[XIImageWidth 0 0 XIImageHeight neg 0 0]
	/XIDataProc load
	XIType 3 eq XIColorValues XIColorSpace ci6tintimage
} def
/XIImage {
	XIImageWidth XIImageHeight XIBitsPerPixel
	[XIImageWidth 0 0 XIImageHeight neg 0 0]
	/XIDataProc load
	false XIChannelCount XIPlateList ci6drawimage
} def
/XG {
	pop pop
} def
/XF {
	13 {pop} repeat
} def
/Xh {
	Adobe_ColorImage_AI6_Vars begin
		gsave
		/XIType exch def
		/XIImageHeight exch def
		/XIImageWidth exch def
		/XIImageMatrix exch def
		0 0 moveto
		XIImageMatrix concat
		XIImageWidth XIImageHeight scale
		
		/_lp /null ddef
		_fc
		/_lp /imagemask ddef
 end
} def
/XH {
	Adobe_ColorImage_AI6_Vars begin
		grestore
 end
} def
/XIEnable {
	Adobe_ColorImage_AI6_Vars /XIEnable 3 -1 roll put
} def
/XC {
	Adobe_ColorImage_AI6_Vars begin
		ci6colormake
		/XIColorSpace exch def
		/XIColorValues exch def
 end
} def
/XIPlates {
	Adobe_ColorImage_AI6_Vars begin
		/XIPlateList exch def
 end
} def
/XI
{
	Adobe_ColorImage_AI6_Vars begin
		gsave
		/XIType exch def
		cvi dup
		256 idiv /XICompression exch store
		256 mod /XIEncoding exch store
		pop pop
		/XIChannelCount exch def
		/XIBitsPerPixel exch def
		/XIImageHeight exch def
		/XIImageWidth exch def
		pop pop pop pop
		/XIImageMatrix exch def
		XIBitsPerPixel 1 eq {
			XIImageWidth 8 div ceiling cvi
		}{
			XIImageWidth XIChannelCount mul
		} ifelse
		/XIRowBytes exch def
		XIEnable {
			/XIBuffer3 XIImageWidth string def
			XICompression 0 eq {
				/XIBuffer1 XIRowBytes string def
				XIEncoding 0 eq {
					{currentfile XIBuffer1 readhexstring pop}
				}{
					{currentfile XIBuffer1 readstring pop}
				} ifelse
			}{
				/XIBuffer1 256 string def
				/XIBuffer2 XIRowBytes string def
				{currentfile XIBuffer1 readline pop (%) anchorsearch {pop} if}
				/ASCII85Decode filter /DCTDecode filter
				/XIFile exch def
				{XIFile XIBuffer2 readstring pop}
			} ifelse
			/XIDataProc exch def
			
			XIType 1 ne {
				0 setgray
			} if
			XIType 1 eq {
				XIImageMask
			}{
				XIType 2 eq XIType 3 eq or {
					XIImageTint
				}{
					XIImage
				} ifelse
			} ifelse
		}{
			XINullImage
		} ifelse
		/XIPlateList false def
		grestore
 end
} def
end
%%EndProcSet
%%BeginResource: procset Adobe_Illustrator_AI5 1.3 0
%%Title: (Adobe Illustrator (R) Version 8.0 Full Prolog)
%%Version: 1.3 0
%%CreationDate: (3/7/1994) ()
%%Copyright: ((C) 1987-1998 Adobe Systems Incorporated All Rights Reserved)
currentpacking true setpacking
userdict /Adobe_Illustrator_AI5_vars 112 dict dup begin
put
/_?cmyk false def
/_eo false def
/_lp /none def
/_pf
{
} def
/_ps
{
} def
/_psf
{
} def
/_pss
{
} def
/_pjsf
{
} def
/_pjss
{
} def
/_pola 0 def
/_doClip 0 def
/cf currentflat def
/_lineorientation 0 def
/_charorientation 0 def
/_yokoorientation 0 def
/_tm matrix def
/_renderStart
[
/e0 /r0 /a0 /o0 /e1 /r1 /a1 /i0
] def
/_renderEnd
[
null null null null /i1 /i1 /i1 /i1
] def
/_render -1 def
/_shift [0 0] def
/_ax 0 def
/_ay 0 def
/_cx 0 def
/_cy 0 def
/_leading
[
0 0
] def
/_ctm matrix def
/_mtx matrix def
/_sp 16#020 def
/_hyphen (-) def
/_fontSize 0 def
/_fontAscent 0 def
/_fontDescent 0 def
/_fontHeight 0 def
/_fontRotateAdjust 0 def
/Ss 256 string def
Ss 0 (fonts/) putinterval
/_cnt 0 def
/_scale [1 1] def
/_nativeEncoding 0 def
/_useNativeEncoding 0 def
/_tempEncode 0 def
/_pntr 0 def
/_tDict 2 dict def
/_hfname 100 string def
/_hffound false def
/Tx
{
} def
/Tj
{
} def
/CRender
{
} def
/_AI3_savepage
{
} def
/_gf null def
/_cf 4 array def
/_rgbf 3 array def
/_if null def
/_of false def
/_fc
{
} def
/_gs null def
/_cs 4 array def
/_rgbs 3 array def
/_is null def
/_os false def
/_sc
{
} def
/_pd 1 dict def
/_ed 15 dict def
/_pm matrix def
/_fm null def
/_fd null def
/_fdd null def
/_sm null def
/_sd null def
/_sdd null def
/_i null def
/_lobyte 0 def
/_hibyte 0 def
/_cproc null def
/_cscript 0 def
/_hvax 0 def
/_hvay 0 def
/_hvwb 0 def
/_hvcx 0 def
/_hvcy 0 def
/_bitfont null def
/_bitlobyte 0 def
/_bithibyte 0 def
/_bitkey null def
/_bitdata null def
/_bitindex 0 def
/discardSave null def
/buffer 256 string def
/beginString null def
/endString null def
/endStringLength null def
/layerCnt 1 def
/layerCount 1 def
/perCent (%) 0 get def
/perCentSeen? false def
/newBuff null def
/newBuffButFirst null def
/newBuffLast null def
/clipForward? false def
end
userdict /Adobe_Illustrator_AI5 known not {
	userdict /Adobe_Illustrator_AI5 100 dict put
} if
userdict /Adobe_Illustrator_AI5 get begin
/initialize
{
	Adobe_Illustrator_AI5 dup begin
	Adobe_Illustrator_AI5_vars begin
	/_aicmykps where {pop /_?cmyk _aicmykps def}if
	discardDict
	{
		bind pop pop
	} forall
	dup /nc get begin
	{
		dup xcheck 1 index type /operatortype ne and
		{
			bind
		} if
		pop pop
	} forall
 end
	newpath
} def
/terminate
{
 end
 end
} def
/_
null def
/ddef
{
	Adobe_Illustrator_AI5_vars 3 1 roll put
} def
/xput
{
	dup load dup length exch maxlength eq
	{
		dup dup load dup
		length 2 mul dict copy def
	} if
	load begin
	def
 end
} def
/npop
{
	{
		pop
	} repeat
} def
/hswj
{
	dup stringwidth 3 2 roll
	{
		_hvwb eq { exch _hvcx add exch _hvcy add } if
		exch _hvax add exch _hvay add
	} cforall
} def
/vswj
{
	0 0 3 -1 roll
	{
		dup 255 le
		_charorientation 1 eq
		and
		{
			dup cstring stringwidth 5 2 roll
			_hvwb eq { exch _hvcy sub exch _hvcx sub } if
			exch _hvay sub exch _hvax sub
			4 -1 roll sub exch
			3 -1 roll sub exch
		}
		{
			_hvwb eq { exch _hvcy sub exch _hvcx sub } if
			exch _hvay sub exch _hvax sub
			_fontHeight sub
		} ifelse
	} cforall
} def
/swj
{
	6 1 roll
	/_hvay exch ddef
	/_hvax exch ddef
	/_hvwb exch ddef
	/_hvcy exch ddef
	/_hvcx exch ddef
	_lineorientation 0 eq { hswj } { vswj } ifelse
} def
/sw
{
	0 0 0 6 3 roll swj
} def
/vjss
{
	4 1 roll
	{
		dup cstring
		dup length 1 eq
		_charorientation 1 eq
		and
		{
			-90 rotate
			currentpoint
			_fontRotateAdjust add
			moveto
			gsave
			false charpath currentpoint
			5 index setmatrix stroke
			grestore
			_fontRotateAdjust sub
			moveto
			_sp eq
			{
				5 index 5 index rmoveto
			} if
			2 copy rmoveto
			90 rotate
		}
		{
			currentpoint
			_fontHeight sub
			5 index sub
			3 index _sp eq
			{
				9 index sub
			} if
	
			currentpoint
			exch 4 index stringwidth pop 2 div sub
			exch _fontAscent sub
			moveto
	
			gsave
			2 index false charpath
			6 index setmatrix stroke
			grestore
	
			moveto pop pop
		} ifelse
	} cforall
	6 npop
} def
/hjss
{
	4 1 roll
	{
		dup cstring
		gsave
		false charpath currentpoint
		5 index setmatrix stroke
		grestore
		moveto
		_sp eq
		{
			5 index 5 index rmoveto
		} if
		2 copy rmoveto
	} cforall
	6 npop
} def
/jss
{
	_lineorientation 0 eq { hjss } { vjss } ifelse
} def
/ss
{
	0 0 0 7 3 roll jss
} def
/vjsp
{
	4 1 roll
	{
		dup cstring
		dup length 1 eq
		_charorientation 1 eq
		and
		{
			-90 rotate
			currentpoint
			_fontRotateAdjust add
			moveto
			false charpath
            currentpoint
			_fontRotateAdjust sub
			moveto
			_sp eq
			{
				5 index 5 index rmoveto
			} if
			2 copy rmoveto
			90 rotate
		}
		{
			currentpoint
			_fontHeight sub
			5 index sub
			3 index _sp eq
			{
				9 index sub
			} if
	
			currentpoint
			exch 4 index stringwidth pop 2 div sub
			exch _fontAscent sub
			moveto
	
			2 index false charpath
	
			moveto pop pop
		} ifelse
	} cforall
	6 npop
} def
/hjsp
{
    4 1 roll
    {
        dup cstring
        false charpath
        _sp eq
        {
            5 index 5 index rmoveto
        } if
        2 copy rmoveto
    } cforall
    6 npop
} def
/jsp
{
	matrix currentmatrix
    _lineorientation 0 eq {hjsp} {vjsp} ifelse
} def
/sp
{
    matrix currentmatrix
    0 0 0 7 3 roll
    _lineorientation 0 eq {hjsp} {vjsp} ifelse
} def
/pl
{
	transform
	0.25 sub round 0.25 add exch
	0.25 sub round 0.25 add exch
	itransform
} def
/setstrokeadjust where
{
	pop true setstrokeadjust
	/c
	{
		curveto
	} def
	/C
	/c load def
	/v
	{
		currentpoint 6 2 roll curveto
	} def
	/V
	/v load def
	/y
	{
		2 copy curveto
	} def
	/Y
	/y load def
	/l
	{
		lineto
	} def
	/L
	/l load def
	/m
	{
		moveto
	} def
}
{
	/c
	{
		pl curveto
	} def
	/C
	/c load def
	/v
	{
		currentpoint 6 2 roll pl curveto
	} def
	/V
	/v load def
	/y
	{
		pl 2 copy curveto
	} def
	/Y
	/y load def
	/l
	{
		pl lineto
	} def
	/L
	/l load def
	/m
	{
		pl moveto
	} def
} ifelse
/d
{
	setdash
} def
/cf
{
} def
/i
{
	dup 0 eq
	{
		pop cf
	} if
	setflat
} def
/j
{
	setlinejoin
} def
/J
{
	setlinecap
} def
/M
{
	setmiterlimit
} def
/w
{
	setlinewidth
} def
/XR
{
	0 ne
	/_eo exch ddef
} def
/H
{
} def
/h
{
	closepath
} def
/N
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			_eo {eoclip} {clip} ifelse /_doClip 0 ddef
		} if
		newpath
	}
	{
		/CRender
		{
			N
		} ddef
	} ifelse
} def
/n
{
	N
} def
/F
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			gsave _pf grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _fc
			/_doClip 0 ddef
		}
		{
			_pf
		} ifelse
	}
	{
		/CRender
		{
			F
		} ddef
	} ifelse
} def
/f
{
	closepath
	F
} def
/S
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			gsave _ps grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc
			/_doClip 0 ddef
		}
		{
			_ps
		} ifelse
	}
	{
		/CRender
		{
			S
		} ddef
	} ifelse
} def
/s
{
	closepath
	S
} def
/B
{
	_pola 0 eq
	{
		_doClip 1 eq
		gsave F grestore
		{
			gsave S grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc
			/_doClip 0 ddef
		}
		{
			S
		} ifelse
	}
	{
		/CRender
		{
			B
		} ddef
	} ifelse
} def
/b
{
	closepath
	B
} def
/W
{
	/_doClip 1 ddef
} def
/*
{
	count 0 ne
	{
		dup type /stringtype eq
		{
			pop
		} if
	} if
	newpath
} def
/u
{
} def
/U
{
} def
/q
{
	_pola 0 eq
	{
		gsave
	} if
} def
/Q
{
	_pola 0 eq
	{
		grestore
	} if
} def
/*u
{
	_pola 1 add /_pola exch ddef
} def
/*U
{
	_pola 1 sub /_pola exch ddef
	_pola 0 eq
	{
		CRender
	} if
} def
/D
{
	pop
} def
/*w
{
} def
/*W
{
} def
/`
{
	/_i save ddef
	clipForward?
	{
		nulldevice
	} if
	6 1 roll 4 npop
	concat pop
	userdict begin
	/showpage
	{
	} def
	0 setgray
	0 setlinecap
	1 setlinewidth
	0 setlinejoin
	10 setmiterlimit
	[] 0 setdash
	/setstrokeadjust where {pop false setstrokeadjust} if
	newpath
	0 setgray
	false setoverprint
} def
/~
{
 end
	_i restore
} def
/_rgbtocmyk
{
	3
	{
		1 exch sub 3 1 roll
	} repeat
	3 copy 1 4 1 roll
	3
	{
		3 index 2 copy gt
		{
			exch
		} if
		pop 4 1 roll
	} repeat
	pop pop pop
	4 1 roll
	3
	{
		3 index sub
		3 1 roll
	} repeat
	4 -1 roll
} def
/setrgbfill
{
	_rgbf astore pop
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_rgbf aload pop setrgbcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		hvashow
	} ddef
	/_pjsf
	{
		_fc
		hvawidthshow
	} ddef
	/_lp /none ddef
} def
/setrgbstroke
{
	_rgbs astore pop
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_rgbs aload pop setrgbcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/O
{
	0 ne
	/_of exch ddef
	/_lp /none ddef
} def
/R
{
	0 ne
	/_os exch ddef
	/_lp /none ddef
} def
/g
{
	/_gf exch ddef
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_gf setgray
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		hvashow
	} ddef
	/_pjsf
	{
		_fc
		hvawidthshow
	} ddef
	/_lp /none ddef
} def
/G
{
	/_gs exch ddef
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_gs setgray
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/k
{
	_cf astore pop
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_cf aload pop setcmykcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		hvashow
	} ddef
	/_pjsf
	{
		_fc
		hvawidthshow
	} ddef
	/_lp /none ddef
} def
/K
{
	_cs astore pop
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_cs aload pop setcmykcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/Xa
{
	_?cmyk {
		3 npop k
	}{
		setrgbfill 4 npop
	} ifelse
} def
/XA
{
	_?cmyk {
		3 npop K
	}{
		setrgbstroke 4 npop
	} ifelse
} def
/Xs
{
	/_gf exch ddef
	5 npop
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_gf setAIseparationgray
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		hvashow
	} ddef
	/_pjsf
	{
		_fc
		hvawidthshow
	} ddef
	/_lp /none ddef
} def
/XS
{
	/_gs exch ddef
	5 npop
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_gs setAIseparationgray
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/Xx
{
	exch
	/_gf exch ddef
	0 eq {
		findcmykcustomcolor
	}{
		_?cmyk {true}{/findrgbcustomcolor where{pop false}{true}ifelse}ifelse
		{
			4 1 roll 3 npop
			findcmykcustomcolor
		}{
			8 -4 roll 4 npop
			findrgbcustomcolor
		} ifelse
	} ifelse
	/_if exch ddef
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_if _gf 1 exch sub setcustomcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		hvashow
	} ddef
	/_pjsf
	{
		_fc
		hvawidthshow
	} ddef
	/_lp /none ddef
} def
/XX
{
	exch
	/_gs exch ddef
	0 eq {
		findcmykcustomcolor
	}{
		_?cmyk {true}{/findrgbcustomcolor where{pop false}{true}ifelse}ifelse
		{
			4 1 roll 3 npop
			findcmykcustomcolor
		}{
			8 -4 roll 4 npop
			findrgbcustomcolor
		} ifelse
	} ifelse
	/_is exch ddef
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_is _gs 1 exch sub setcustomcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/x
{
	/_gf exch ddef
	findcmykcustomcolor
	/_if exch ddef
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_if _gf 1 exch sub setcustomcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		hvashow
	} ddef
	/_pjsf
	{
		_fc
		hvawidthshow
	} ddef
	/_lp /none ddef
} def
/X
{
	/_gs exch ddef
	findcmykcustomcolor
	/_is exch ddef
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_is _gs 1 exch sub setcustomcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/XK
{
	3 -1 roll pop
	0 eq
	{
		1 exch sub
		3 {dup 3 1 roll mul 5 1 roll} repeat
		mul 4 1 roll
		K
	}
	{
		1 exch sub 4 1 roll
		3 {1 exch sub 3 index mul 1 exch sub 3 1 roll} repeat
		4 -1 roll pop
		XA
	} ifelse
} def
/Xk
{
	3 -1 roll pop
	0 eq
	{
		1 exch sub
		3 {dup 3 1 roll mul 5 1 roll} repeat
		mul 4 1 roll
		k
	}
	{
		1 exch sub 4 1 roll
		3 {1 exch sub 3 index mul 1 exch sub 3 1 roll} repeat
		4 -1 roll pop
		Xa
	} ifelse
} def
/A
{
	pop
} def
/annotatepage
{
userdict /annotatepage 2 copy known {get exec} {pop pop} ifelse
} def
/XT {
	pop pop
} def
/Xt {
	pop
} def
/discard
{
	save /discardSave exch store
	discardDict begin
	/endString exch store
	gt38?
	{
		2 add
	} if
	load
	stopped
	pop
 end
	discardSave restore
} bind def
userdict /discardDict 7 dict dup begin
put
/pre38Initialize
{
	/endStringLength endString length store
	/newBuff buffer 0 endStringLength getinterval store
	/newBuffButFirst newBuff 1 endStringLength 1 sub getinterval store
	/newBuffLast newBuff endStringLength 1 sub 1 getinterval store
} def
/shiftBuffer
{
	newBuff 0 newBuffButFirst putinterval
	newBuffLast 0
	currentfile read not
	{
	stop
	} if
	put
} def
0
{
	pre38Initialize
	mark
	currentfile newBuff readstring exch pop
	{
		{
			newBuff endString eq
			{
				cleartomark stop
			} if
			shiftBuffer
		} loop
	}
	{
	stop
	} ifelse
} def
1
{
	pre38Initialize
	/beginString exch store
	mark
	currentfile newBuff readstring exch pop
	{
		{
			newBuff beginString eq
			{
				/layerCount dup load 1 add store
			}
			{
				newBuff endString eq
				{
					/layerCount dup load 1 sub store
					layerCount 0 eq
					{
						cleartomark stop
					} if
				} if
			} ifelse
			shiftBuffer
		} loop
	} if
} def
2
{
	mark
	{
		currentfile buffer {readline} stopped {
			% assume error was due to overfilling the buffer
		}{
			not
			{
				stop
			} if
			endString eq {
				cleartomark stop
			} if
		}ifelse
	} loop
} def
3
{
	/beginString exch store
	/layerCnt 1 store
	mark
	{
		currentfile buffer {readline} stopped {
			% assume error was due to overfilling the buffer
		}{
			not
			{
				stop
			} if
			dup beginString eq
			{
				pop /layerCnt dup load 1 add store
			}
			{
				endString eq
				{
					layerCnt 1 eq
					{
						cleartomark stop
					}
					{
						/layerCnt dup load 1 sub store
					} ifelse
				} if
			} ifelse
		}ifelse
	} loop
} def
end
userdict /clipRenderOff 15 dict dup begin
put
{
	/n /N /s /S /f /F /b /B
}
{
	{
		_doClip 1 eq
		{
			/_doClip 0 ddef _eo {eoclip} {clip} ifelse
		} if
		newpath
	} def
} forall
/Tr /pop load def
/Bb {} def
/BB /pop load def
/Bg {12 npop} def
/Bm {6 npop} def
/Bc /Bm load def
/Bh {4 npop} def
end
/Lb
{
	6 npop
	7 2 roll
	5 npop
	0 eq
	{
		0 eq
		{
			(%AI5_BeginLayer) 1 (%AI5_EndLayer--) discard
		}
		{
			
			/clipForward? true def
			
			/Tx /pop load def
			/Tj /pop load def
			
			currentdict end clipRenderOff begin begin
		} ifelse
	}
	{
		0 eq
		{
			save /discardSave exch store
		} if
	} ifelse
} bind def
/LB
{
	discardSave dup null ne
	{
		restore
	}
	{
		pop
		clipForward?
		{
			currentdict
		 end
		 end
		 begin
					
			/clipForward? false ddef
		} if
	} ifelse
} bind def
/Pb
{
	pop pop
	0 (%AI5_EndPalette) discard
} bind def
/Np
{
	0 (%AI5_End_NonPrinting--) discard
} bind def
/Ln /pop load def
/Ap
/pop load def
/Ar
{
	72 exch div
	0 dtransform dup mul exch dup mul add sqrt
	dup 1 lt
	{
		pop 1
	} if
	setflat
} def
/Mb
{
	q
} def
/Md
{
} def
/MB
{
	Q
} def
/nc 4 dict def
nc begin
/setgray
{
	pop
} bind def
/setcmykcolor
{
	4 npop
} bind def
/setrgbcolor
{
	3 npop
} bind def
/setcustomcolor
{
	2 npop
} bind def
currentdict readonly pop
end
/XP
{
	4 npop
} bind def
/XD
{
	pop
} bind def
end
setpacking
%%EndResource
%%BeginResource: procset Adobe_cshow 2.0 8
%%Title: (Writing System Operators)
%%Version: 2.0 8
%%CreationDate: (1/23/89) ()
%%Copyright: ((C) 1992-1996 Adobe Systems Incorporated All Rights Reserved)
currentpacking true setpacking
userdict /Adobe_cshow 14 dict dup begin put
/initialize
{
	Adobe_cshow begin
	Adobe_cshow
	{
		dup xcheck
		{
			bind
		} if
		pop pop
	} forall
 end
	Adobe_cshow begin
} def
/terminate
{
currentdict Adobe_cshow eq
	{
 end
	} if
} def
/cforall
{
	/_lobyte 0 ddef
	/_hibyte 0 ddef
	/_cproc exch ddef
	/_cscript currentfont /FontScript known { currentfont /FontScript get } { -1 } ifelse ddef
	{
		/_lobyte exch ddef
		_hibyte 0 eq
		_cscript 1 eq
		_lobyte 129 ge _lobyte 159 le and
		_lobyte 224 ge _lobyte 252 le and or and
		_cscript 2 eq
		_lobyte 161 ge _lobyte 254 le and and
		_cscript 3 eq
		_lobyte 161 ge _lobyte 254 le and and
    	_cscript 25 eq
		_lobyte 161 ge _lobyte 254 le and and
    	_cscript -1 eq
		or or or or and
		{
			/_hibyte _lobyte ddef
		}
		{
			_hibyte 256 mul _lobyte add
			_cproc
			/_hibyte 0 ddef
		} ifelse
	} forall
} def
/cstring
{
	dup 256 lt
	{
		(s) dup 0 4 3 roll put
	}
	{
		dup 256 idiv exch 256 mod
		(hl) dup dup 0 6 5 roll put 1 4 3 roll put
	} ifelse
} def
/clength
{
	0 exch
	{ 256 lt { 1 } { 2 } ifelse add } cforall
} def
/hawidthshow
{
	{
		dup cstring
		show
		_hvax _hvay rmoveto
		_hvwb eq { _hvcx _hvcy rmoveto } if
	} cforall
} def
/vawidthshow
{
	{
		dup 255 le
		_charorientation 1 eq
		and
		{
			-90 rotate
			0 _fontRotateAdjust rmoveto
			cstring
			_hvcx _hvcy _hvwb _hvax _hvay 6 -1 roll awidthshow
			0 _fontRotateAdjust neg rmoveto
			90 rotate
		}
		{
			currentpoint
			_fontHeight sub
			exch _hvay sub exch _hvax sub
			2 index _hvwb eq { exch _hvcy sub exch _hvcx sub } if
			3 2 roll
			cstring
			dup stringwidth pop 2 div neg _fontAscent neg rmoveto
			show
			moveto
		} ifelse
	} cforall
} def
/hvawidthshow
{
	6 1 roll
	/_hvay exch ddef
	/_hvax exch ddef
	/_hvwb exch ddef
	/_hvcy exch ddef
	/_hvcx exch ddef
	_lineorientation 0 eq { hawidthshow } { vawidthshow } ifelse
} def
/hvwidthshow
{
	0 0 3 -1 roll hvawidthshow
} def
/hvashow
{
	0 0 0 6 -3 roll hvawidthshow
} def
/hvshow
{
	0 0 0 0 0 6 -1 roll hvawidthshow
} def
currentdict readonly pop end
setpacking
%%EndResource
%%BeginResource: procset Adobe_shading_AI8 1.0 0
%%Title: (Adobe Illustrator 8 Shading Procset)
%%Version: 1.0 0
%%CreationDate: (12/17/97) ()
%%Copyright: ((C) 1987-1997 Adobe Systems Incorporated All Rights Reserved)
userdict /defaultpacking currentpacking put true setpacking
userdict /Adobe_shading_AI8 10 dict dup begin put
/initialize {
	Adobe_shading_AI8 begin
	Adobe_shading_AI8 bdprocs
	Mesh /initialize get exec
} def
/terminate {
	currentdict Adobe_shading_AI8 eq {
	 end
	} if
} def
/bdprocs {
	{
		dup xcheck 1 index type /arraytype eq and {
			bind
		} if
		pop pop
	} forall
} def
/X! {pop} def
/X# {pop pop} def
/Mesh 40 dict def
Mesh begin
/initialize {
	Mesh bdprocs
	Mesh begin
		/emulate? /AI8MeshEmulation where {
			pop AI8MeshEmulation
		}{
			systemdict /shfill known not
		} ifelse def
 end
} def
/bd {
	shadingdict begin
} def
/paint {
	emulate? {
	 end
	}{
		/_lp /none ddef _fc /_lp /none ddef
		
		/AIColorSpace AIColorSpace tocolorspace store
		/ColorSpace AIColorSpace topsspace store
		
		version_ge_3010.106 not systemdict /setsmoothness known and {
			0.0001 setsmoothness
		} if
		
		composite? {
			/DataSource getdatasrc def
			Matrix concat
			currentdict end
			shfill
		}{
			AIColorSpace makesmarks AIPlateList markingplate and not isoverprint and {
			 end
			}{
				/ColorSpace /DeviceGray store
				/Decode [0 1 0 1 0 1] store
				/DataSource getplatesrc def
				Matrix concat
				currentdict end
				shfill
			} ifelse
		} ifelse
	} ifelse
} def
/shadingdict 12 dict def
shadingdict begin
	/ShadingType 6 def
	/BitsPerCoordinate 16 def
	/BitsPerComponent 8 def
	/BitsPerFlag 8 def
end
/datafile null def
/databuf 256 string def
/dataptr 0 def
/srcspace null def
/srcchannels 0 def
/dstchannels 0 def
/dstplate 0 def
/srctodstcolor null def
/getplatesrc {
	/srcspace AIColorSpace store
	/srcchannels AIColorSpace getnchannels store
	/dstchannels 1 store
	/dstplate getplateindex store
	/srctodstcolor srcspace makesmarks {
		dstplate 4 eq {
			{1 exch sub}
		}{
			{srcspace tocmyk 3 dstplate sub index 1 exch sub 5 1 roll 4 {pop} repeat}
		} ifelse
	}{
		{srcchannels {pop} repeat 1}
	} ifelse store
	/datafile getdatasrc store
	/rdpatch168 load DataLength () /SubFileDecode filter
} def
/getdatasrc {
	/rdcmntline load /ASCII85Decode filter
} def
/rdpatch168 {
	/dataptr 0 store
	49 rdcount
	4 {
		dup {pop srcchannels getint8} if
		dup {pop srctodstcolor dstchannels putint8 true} if
	} repeat
	{databuf 0 dataptr getinterval}{()} ifelse
} def
/rdpatch3216 {
	/dataptr 0 store
	97 rdcount
	4 {
		dup {pop srcchannels getint16} if
		dup {pop srctodstcolor dstchannels putint16 true} if
	} repeat
	{databuf 0 dataptr getinterval}{()} ifelse
} def
/rdcount {
	dup 0 gt {
		datafile databuf dataptr 4 -1 roll getinterval readstring
		exch length dataptr add /dataptr exch store
	}{
		true
	} ifelse
} def
/getint8 {
	mark true 3 -1 roll
	{
		dup {pop datafile read} if
		dup {pop 255 div true} if
	} repeat
	{
		counttomark 1 add -1 roll pop true
	}{
		cleartomark false
	} ifelse
} def
/putint8 {
	dup dataptr add /dataptr exch store
	dataptr exch
	{
		1 sub exch
		255 mul cvi
		databuf 2 index
		3 -1 roll put
	} repeat
	pop
} def 
/getint16 {
	mark true 3 -1 roll
	{
		dup {pop datafile read} if
		dup {pop 256 mul datafile read} if
		dup {pop add 65535 div true} if
	} repeat
	{
		counttomark 1 add -1 roll pop true
	}{
		cleartomark false
	} ifelse
} def
/putint16 {
	dup 2 mul dataptr add /dataptr exch store
	dataptr exch
	{
		2 sub exch
		65535 mul cvi dup
		256 idiv databuf 3 index 3 -1 roll put
		256 mod databuf 2 index 1 add 3 -1 roll put
	} repeat
	pop
} def 
/srcbuf 256 string def
/rdcmntline {
	currentfile srcbuf readline pop
	(%) anchorsearch {pop} if
} def
/getplateindex {
	0 [cyan? magenta? yellow? black? customColor?] {{exit} if 1 add} forall
} def
/aicsarray 4 array def
/aicsaltvals 4 array def
/aicsaltcolr aicsaltvals def
/tocolorspace {
	dup type /arraytype eq {
		mark exch aload pop
		aicsarray 0 3 -1 roll put
		aicsarray 1 3 -1 roll put
		dup aicsarray 2 3 -1 roll put
		gettintxform aicsarray 3 3 -1 roll put
		counttomark aicsaltvals 0 3 -1 roll getinterval /aicsaltcolr exch store
		aicsaltcolr astore pop pop
		aicsarray
	} if
} def
/subtintxform {aicsaltcolr {1 index mul exch} forall pop} def
/addtintxform {aicsaltcolr {1 sub 1 index mul 1 add exch} forall pop} def
/gettintxform {
	/DeviceRGB eq {/addtintxform}{/subtintxform} ifelse load
} def
/getnchannels {
	dup type /arraytype eq {0 get} if
	colorspacedict exch get begin Channels end
} def
/makesmarks {
	composite? {
		pop true
	}{
		dup dup type /arraytype eq {0 get} if
		colorspacedict exch get begin MarksPlate end
	} ifelse
} def
/markingplate {
	composite? {
		pop true
	}{
		dup type /arraytype eq {
			dup length getplateindex gt {getplateindex get}{pop false} ifelse
		} if
	} ifelse
} def
/tocmyk {
	dup dup type /arraytype eq {0 get} if
	colorspacedict exch get begin ToCMYK end
} def
/topsspace {
	dup dup type /arraytype eq {0 get} if
	colorspacedict exch get begin ToPSSpace end
} def
/colorspacedict 5 dict dup begin
	/DeviceGray 4 dict dup begin
		/Channels 1 def
		/MarksPlate {pop black?} def
		/ToCMYK {pop 1 exch sub 0 0 0 4 -1 roll} def
		/ToPSSpace {} def
 end def
	/DeviceRGB 4 dict dup begin
		/Channels 3 def
		/MarksPlate {pop isCMYKSep?} def
		/ToCMYK {pop _rgbtocmyk} def
		/ToPSSpace {} def
 end def
	/DeviceCMYK 4 dict dup begin
		/Channels 4 def
		/MarksPlate {pop isCMYKSep?} def
		/ToCMYK {pop} def
		/ToPSSpace {} def
 end def
	/Separation 4 dict dup begin
		/Channels 1 def
		/MarksPlate {
			/findcmykcustomcolor where {
				pop dup 1 exch ToCMYK 5 -1 roll 1 get
				findcmykcustomcolor 1 setcustomcolor
				systemdict /currentgray get exec
				1 ne
			}{
				pop false
			} ifelse
		} def
		/ToCMYK {
			dup 2 get mark exch 4 2 roll
			3 get exec
			counttomark -1 roll tocmyk
			5 -1 roll pop
		} def
		/ToPSSpace {} def
 end def
	/Process 4 dict dup begin
		/Channels 1 def
		/MarksPlate {
			isCMYKSep? {
				1 exch ToCMYK 4 array astore getplateindex get 0 ne 
			}{
				pop false
			} ifelse
		} def
		/ToCMYK {
			dup 2 get mark exch 4 2 roll
			3 get exec
			counttomark -1 roll tocmyk
			5 -1 roll pop
		} def
		/ToPSSpace {
			4 array copy dup 0 /Separation put
		} def
 end def
end def
/isoverprint {
	/currentoverprint where {pop currentoverprint}{_of} ifelse
} def
/version_ge_3010.106 {
   version {cvr} stopped {
      pop
      false
   }{
      3010.106 ge
   } ifelse
} def
end
end
defaultpacking setpacking
%%EndResource
%%EndProlog%%BeginSetupuserdict /_useSmoothShade true putuserdict /_aicmykps false putuserdict /_forceToCMYK false putAdobe_level2_AI5 /initialize get exec
Adobe_cshow /initialize get exec
Adobe_Illustrator_AI5_vars Adobe_Illustrator_AI5 AGM_Gradient /initializeAI get exec
Adobe_ColorImage_AI6 /initialize get exec
Adobe_shading_AI8 /initialize get exec
Adobe_Illustrator_AI5 /initialize get exec
%AI5_Begin_NonPrintingNp%AI8_PluginGroupInfo(Adobe Vectorized Object) (Image Tracing) (Vectorize.aip)%AI8_PluginGroupInfo(Adobe Flare Plugin) (Flare) (Flare.aip)%AI8_PluginGroupInfo(Adobe Deform Plugin) (Adobe Envelope Plugin) (Envelope and Warp.aip)%AI8_PluginGroupInfo(Adobe Planar Group) (Adobe Live Paint Plugin) (Live Paint.aip)%AI8_PluginGroupInfo(Adobe Perspective Plugin Group) (Adobe Perspective Plugin Group) (Perspective.aip)%AI8_PluginGroupInfo(Adobe Path Blends) (Adobe Blends Plugin) (LiveBlends.aip)%AI8_PluginGroupInfo(Adobe Scatter Brush Tool) (Adobe Scatter Brush Plugin) (ScatterBrushTool.aip)%AI8_PluginGroupInfo(Adobe Scatter Brush Tool) (Adobe Scatter Brush Plugin) (ScatterBrushTool.aip)%AI8_PluginGroupInfo(Adobe PatternOnPath Brush Tool) (Adobe Pattern Brush Plugin) (ArtBrushTool.aip)%AI8_PluginGroupInfo(Adobe PatternOnPath Brush Tool) (Adobe Pattern Brush Plugin) (ArtBrushTool.aip)%AI8_PluginGroupInfo(Adobe ArtOnPath Brush Tool) (Adobe Art Brush Plugin) (ArtBrushTool.aip)%AI8_PluginGroupInfo(Adobe ArtOnPath Brush Tool) (Adobe Art Brush Plugin) (ArtBrushTool.aip)%AI8_PluginGroupInfo(Adobe Calligraphic Brush Tool) (Adobe Calligraphic Brush Plugin) (CalligBrushTool.aip)%AI8_PluginGroupInfo(Adobe Symbolism) (Adobe Symbolism) (ParticleSystem.aip)%AI8_PluginGroupInfo(Adobe Pattern Editor Plugin Group) (Adobe Pattern Editor Plugin Group) (SwatchLibraries.aip)%AI8_PluginGroupInfo(Pathfinder Suite) (Adobe Compound Shape) (PathFinderS.aip)%AI5_End_NonPrinting--2 Bn%AI5_BeginGradient: (Unnamed gradient)(Unnamed gradient) 0 2 Bd[<E9E7E5E3E0DEDCDAD8D7D5D4D2D1D0CECCCAC9C9C8C7C6C5C3C2C1C1C0BFBFBEBDBDBCBBBAB9B9B8B7B6B6B5B4B4B3B2B1><C9C7C6C4C3C1C0BEBDBCBAB9B8B7B6B5B3B2B1B1B0AFAEADABAAA9A8A7A7A6A6A5A4A3A3A2A1A0A09F9E9D9D9C9B9B9A99><9E9E9E9E9E9E9E9E9D9D9D9D9D9D9D9D9D9D9D9C9C9C9C9C9B9B9B9A9A999999989897969695959494939392919190908F><F9F7F6F4F3F1F0EEEDECEBE9E9E8E7E5E4E2E1DFDEDCDAD9D5D3D1D0CECDCBCAC9C7C5C3C1BFBDBBB9B7B5B3B2B0AEACAA><000102030405060708090A0B0C0D0E0F1011121314151617191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F3031><000102030405060708090A0B0C0D0E0F1011121314151617191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F3031><000102030405060708090A0B0C0D0E0F1011121314151617191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F3031>4 %_Br[0.69546 0.600061 0.562341 0.666834 0.192157 0.192157 0.192157 2 50 100 %_BS%_0.69546 0.600061 0.562341 0.666834 0.192157 0.192157 0.192157 2 50 100 Bs0.912474 0.787625 0.619837 0.97467 0 0 0 2 50 0 %_BS%_0.912474 0.787625 0.619837 0.97467 0 0 0 2 50 0 BsBD%AI5_EndGradient%AI5_BeginGradient: (Unnamed gradient 2)(Unnamed gradient 2) 0 2 Bd[<A1A1A1A3A3A3A4A6A6A6A6A8A7A7A7A7A9A9AAAAACACACACACAEAFAFAFB2B2B2B2B4B4B4B7B8BABABBBBBEBEBEBFC2C2C2C2C2C4C4C4C4C6C7C8C8C9CCCDCECED1D2D3D4D6D7D7><FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFDFDFDFAF7F5F4F2F0EEEEECECEBEBE9E8><474849494A4B4C4C4D4D4E4E4F4F5051515152535354555657575858595A5B5C5C5D5E5E5F6060616263636466676767686969696A6B6B6B6C6E7072737577797A7B7D7E7F8081><40424444474A4D4D5053555557595B5E5D60626464676A6D6F6F72747777797B7E7E80828588888B8E909093959797999B9DA09FA1A4A6A6A8ABADB0B0B2B4B6B6B9BBBDBDBFC1><6867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A4948474645434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221><15151515151514141414141414141414131313131313131313131212121212121212121211111111111111111111101010101010101010100F0F0F0F0F0F0F0F0F0F0E0E0E0E0E><575655555453525251504F4F4E4D4C4B4B4A494848474645444443424141403F3E3E3D3C3B3A3A393837373635343433323130302F2E2D2D2C2B2A292928272626252423232221>4 %_Br[0.842863 0.909728 0.505425 0.75848 0.129412 0.054902 0.129412 2 50 100 %_BS%_0.842863 0.909728 0.505425 0.75848 0.129412 0.054902 0.129412 2 50 100 Bs0.630121 1 0.277714 0.251377 0.407843 0.082353 0.341176 2 50 0 %_BS%_0.630121 1 0.277714 0.251377 0.407843 0.082353 0.341176 2 50 0 BsBD%AI5_EndGradient%AI5_BeginPalette0 0 Pb0.912474 0.787625 0.619837 0.97467 ([Registration]) 0 Xs([Registration])PcPB%AI5_EndPalette%%EndSetup%AI5_BeginLayer1 1 1 1 0 0 1 0 79 128 255 0 50 Lb(Layer 1) Ln0 AuuUuuU*u1 D0 O0 J 0 j 1 w 10 M []0 d0 XR0 g298.9917 -134.3574 m298.9917 -134.3574 L299.4038 -133.7461 299.2427 -132.916 298.6313 -132.5039 C298.6313 -132.5039 L288.6685 -125.7842 L288.0571 -125.3711 287.2271 -125.5332 286.8149 -126.1445 C286.8149 -126.1445 L286.4023 -126.7559 286.5635 -127.5859 287.1753 -127.998 C297.1377 -134.7178 L297.749 -135.1299 298.5791 -134.9688 298.9917 -134.3574 C298.9917 -134.3574 Lf0 g308.7676 -131.6904 m308.7676 -131.6904 L309.1797 -131.0791 309.0176 -130.249 308.4063 -129.8369 C308.4063 -129.8369 L294.0688 -120.166 L293.4575 -119.7529 292.6274 -119.9141 292.2148 -120.5254 C292.2148 -120.5254 L291.8027 -121.1367 291.9639 -121.9668 292.5752 -122.3799 C306.9141 -132.0508 L307.5254 -132.4629 308.3555 -132.3018 308.7676 -131.6904 Cf0 g313.7188 -125.7695 m313.7188 -125.7695 L314.1309 -125.1582 313.9707 -124.3281 313.3594 -123.916 C313.3594 -123.916 L303.396 -117.1953 L302.7847 -116.7832 301.9546 -116.9443 301.5425 -117.5557 C301.5425 -117.5557 L301.1299 -118.168 301.291 -118.9971 301.9028 -119.4102 C311.8652 -126.1299 L312.4766 -126.542 313.3066 -126.3809 313.7188 -125.7695 C313.7188 -125.7695 Lf0 g315.8389 -96.3604 m315.8389 -96.3604 L315.4258 -96.9717 315.5879 -97.8018 316.1992 -98.2139 C326.1621 -104.9346 L326.7734 -105.3467 327.6035 -105.1855 328.0156 -104.5742 C328.0156 -104.5742 L328.4277 -103.9629 328.2666 -103.1328 327.6553 -102.7207 C317.6924 -96 L317.0811 -95.5879 316.251 -95.749 315.8389 -96.3604 Cf314.6504 -86.2979 m314.6504 -86.2979 L314.2373 -86.9092 314.3984 -87.7393 315.0098 -88.1514 C329.3477 -97.8223 L329.959 -98.2354 330.7891 -98.0732 331.2012 -97.4619 C331.2012 -97.4619 L331.6143 -96.8506 331.4531 -96.0205 330.8418 -95.6084 C316.5039 -85.9375 L315.8926 -85.5254 315.0625 -85.6865 314.6504 -86.2979 CBb1 (Unnamed gradient) 7.98193 -5.45313 0 1 0 49.2374 49.2374 0 -414924.234 -380005.359 Bg0 -49.2374 242.1615 0 187.9277 -85.75 Xm0 -388827.015 242.1615 0 187.9277 388741.265 Bc0 -49.2374 242.1615 0 187.9277 -85.75 Bm0 -388827.015 242.1615 0 187.9277 -134.9873 Bcf0 BB*U*u0 D0 g316 -116.5732 m316.1035 -119.457 315.6523 -122.0791 314.168 -124.3301 C314.1484 -124.3613 314.1289 -124.3906 314.1074 -124.4209 C309.2549 -131.4531 297.0742 -130.2656 286.4219 -133.6543 C286.3018 -130.792 286.7178 -128.1855 288.1323 -125.9385 C288.1885 -125.8467 288.25 -125.7588 288.3125 -125.6719 C293.2651 -118.8066 305.4072 -119.9824 316 -116.5732 Cf1 D319.7139 -115.1338 m323.3008 -113.4697 326.5615 -111.0371 329.1035 -107.2695 C329.127 -107.2344 329.1504 -107.1992 329.1738 -107.1641 c329.1777 -107.1582 329.1807 -107.1523 329.1846 -107.1475 c329.209 -107.1123 329.2324 -107.0781 329.2559 -107.043 C331.6875 -103.4375 332.7393 -99.6797 333 -95.9023 C333 -95.9023 L327.4551 -87.9141 L328.9395 -94.8613 330.2461 -101.1621 327.1777 -105.7695 C327.167 -105.7861 327.1553 -105.8027 327.1445 -105.8193 c325.4785 -108.2568 322.9004 -109.7217 319.7969 -110.7432 C319.3213 -100.8818 314.9063 -91.123 316.7061 -84 C313.707 -84.0039 L310.2002 -93.3857 313.957 -103.3906 315.4551 -111.875 C305.7944 -113.9131 293.3906 -114.3389 286.4048 -124.3838 C286.4028 -124.3828 L286.3423 -124.4727 286.2827 -124.5615 286.2241 -124.6514 C286.2236 -124.6523 L284.0239 -128.0156 283.0054 -131.5322 282.6909 -135.083 C280.6685 -136.0117 278.748 -137.1807 277 -138.6934 C282.5947 -138.6953 L285.4785 -138.6963 L287.0493 -138.6973 L287.0283 -138.585 287.0078 -138.4736 286.9883 -138.3623 C296.6836 -136.3379 309.0859 -135.8721 316.0137 -125.707 C316.0137 -125.707 L316.0342 -125.6768 316.0547 -125.6465 316.0742 -125.6162 C316.0742 -125.6162 L318.3301 -122.2393 319.3809 -118.7041 319.7139 -115.1338 C319.7139 -115.1338 LBb1 (Unnamed gradient 2) -5.67773 5.1875 0 1 8.62297 -61.3556 -61.3556 -8.62297 466839.398 566241.268 Bg8.62297 61.3556 -294.7055 41.4182 448.9941 -162.8584 Xm67977.625 483685.923 -294.7055 41.4182 -67528.6328 -483848.767 Bc8.62297 61.3556 -294.7055 41.4182 448.9941 -162.8584 Bm67977.625 483685.923 -294.7055 41.4182 457.6172 -101.5029 Bcf0 BB*UUULB%AI5_EndLayer--%%PageTrailergsave annotatepage grestore showpage%%TrailerAdobe_Illustrator_AI5 /terminate get exec
Adobe_shading_AI8 /terminate get exec
Adobe_ColorImage_AI6 /terminate get exec
AGM_Gradient /terminate get exec
Adobe_cshow /terminate get exec
Adobe_level2_AI5 /terminate get exec
%%EOF